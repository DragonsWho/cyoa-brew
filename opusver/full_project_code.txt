PROJECT STRUCTURE:
==================
[opusver/]
    generate_test_image.html
    index.html
    readme
    [config/]
        example.json
        schema.json
        test_config.json
        test_image.png
    [docs/]
        llm-guide.md
        rule-catalog.md
    [src/]
        main.js
        [core/]
            effects.js
            engine.js
            rules.js
            state.js
        [ui/]
            controls.js
            editor.js
            renderer.js
            rule-builder.js
            tooltip.js
        [utils/]
            autodetect.js
            coords.js
            evaluator.js
    [styles/]
        main.css
        themes.css
==================

<file path="generate_test_image.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Image Generator</title>
    <style>
        body {
            margin: 20px;
            font-family: Arial, sans-serif;
            background: #222;
            color: #fff;
        }
        
        h1 { color: #4CAF50; }
        
        .controls {
            margin: 20px 0;
            padding: 20px;
            background: #333;
            border-radius: 8px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        canvas {
            border: 2px solid #555;
            display: block;
            margin: 20px 0;
            max-width: 100%;
            background: white;
        }
        
        .info {
            background: #444;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        code {
            background: #555;
            padding: 2px 6px;
            border-radius: 3px;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>üé® Test Image Generator</h1>
    
    <div class="info">
        <strong>Instructions:</strong>
        <ol>
            <li>Click "Generate Test Image" below</li>
            <li>Right-click the image ‚Üí "Save image as..."</li>
            <li>Save to <code>config/test_image.png</code></li>
            <li>Run <code>index.html</code> to see it in action!</li>
        </ol>
    </div>
    
    <div class="controls">
        <button onclick="generateImage()">üé® Generate Test Image</button>
        <button onclick="downloadImage()">üíæ Download Image</button>
    </div>
    
    <canvas id="canvas" width="1920" height="1080"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function generateImage() {
            // Background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = '#eee';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Test CYOA - Rule Examples', canvas.width / 2, 120);

            // Groups with boxes
            const groups = [
                { title: 'Free Items', y: 220, items: 3, color: '#4CAF50' },
                { title: 'Paid Items', y: 440, items: 3, color: '#FF9800' },
                { title: 'Requirements', y: 660, items: 3, color: '#2196F3' },
                { title: 'Incompatible', y: 880, items: 2, color: '#F44336' }
            ];

            groups.forEach(group => {
                // Group background
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fillRect(50, group.y, 1240, 200);

                // Group title
                ctx.fillStyle = group.color;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(group.title, 70, group.y + 30);

                // Item boxes
                for (let i = 0; i < group.items; i++) {
                    const x = 50 + i * 420;
                    const y = group.y + 30;

                    // Box
                    ctx.strokeStyle = group.color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, 400, 150);

                    // Item title
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Item ${i + 1}`, x + 200, y + 80);
                }
            });

            // Right column - Choose 1
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            ctx.fillRect(1310, 220, 560, 640);
            
            ctx.fillStyle = '#9C27B0';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Choose Only 1', 1330, 250);

            for (let i = 0; i < 3; i++) {
                const y = 220 + 30 + i * 170;
                ctx.strokeStyle = '#9C27B0';
                ctx.lineWidth = 3;
                ctx.strokeRect(1330, y, 520, 150);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Choice ${String.fromCharCode(65 + i)}`, 1590, y + 80);
            }

            // Budget group
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            ctx.fillRect(1310, 880, 560, 200);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Budget: 5 Free Picks', 1330, 910);

            for (let i = 0; i < 2; i++) {
                const x = 1330 + i * 270;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, 910, 250, 150);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Budget ${i + 1}`, x + 125, 990);
            }

            // Footer
            ctx.fillStyle = '#666';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Generated Test Image - Click items to select them!', canvas.width / 2, canvas.height - 30);

            console.log('‚úÖ Image generated!');
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'test_image.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            console.log('üíæ Download started!');
        }

        // Auto-generate on load
        window.onload = () => {
            generateImage();
        };
    </script>
</body>
</html>
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYOA Brew</title>
    <link rel="stylesheet" href="styles/main.css">
        <script type="importmap">
        {
            "imports": {
                "@gradio/client": "https://cdn.jsdelivr.net/npm/@gradio/client/+esm"
            }
        }
    </script>
</head>
<body>
    <div id="app">
        <!-- Top controls -->
        <div class="top-controls">
            <button id="text-toggle" class="ctrl-btn">üìñ Translation</button>
            <button id="edit-toggle" class="ctrl-btn">‚úèÔ∏è Edit</button>
            <button id="reset-btn" class="ctrl-btn">üîÑ Reset</button>
        </div>
        
        <!-- Game content -->
        <div id="game-wrapper"></div>
        
        <!-- Points bar -->
        <div id="points-bar"></div>
        
        <!-- Tooltip -->
        <div id="tooltip"></div>
    </div>

    <!-- Loading indicator -->
    <div id="loading" style="
        position: fixed; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%);
        font-size: 24px;
        color: #fff;
        text-align: center;
    ">
        Loading CYOA...<br>
        <small style="color: #888; font-size: 14px;">
            Check console (F12) if this takes too long
        </small>
    </div>

    <script type="module" src="src/main.js"></script>
</body>
</html>
</file>

<file path="config/example.json">

</file>

<file path="config/schema.json">

</file>

<file path="config/test_config.json">
{
  "meta": {
    "title": "Test CYOA - Advanced Mechanics",
    "pages": [
      "config/test_image.png"
    ]
  },
  "points": [
    { "id": "points", "name": "Points", "start": 50 }
  ],
  "groups": [
    {
      "id": "modifiers",
      "title": "Global Modifiers",
      "page": 0,
      "coords": { "x": 50, "y": 50, "w": 1200, "h": 150 },
      "items": [
        {
          "id": "backpack",
          "title": "Magic Backpack",
          "description": "Increases limit in 'Choose Only 1' by +2.\nAllows you to pick A, B, and C!",
          "coords": { "x": 50, "y": 50, "w": 350, "h": 120 },
          "cost": [{ "currency": "points", "value": -5 }],
          "effects": [
            {
              "type": "modify_group_limit",
              "group_id": "max_choices",
              "value": 2
            }
          ]
        },
        {
          "id": "merchant_ring",
          "title": "Merchant Ring",
          "description": "All 'Magic' items cost 50% less!\nWatch the prices of Fire/Ice change.",
          "coords": { "x": 420, "y": 50, "w": 350, "h": 120 },
          "cost": [{ "currency": "points", "value": -10 }],
          "effects": [
            {
              "type": "modify_cost",
              "tag": "magic",
              "mode": "multiply",
              "value": 0.5
            }
          ]
        },
        {
          "id": "gamblers_coin",
          "title": "Gambler's Coin",
          "description": "Feeling Lucky?\nRolls a D20 for bonus points!",
          "coords": { "x": 790, "y": 50, "w": 350, "h": 120 },
          "cost": [],
          "effects": [
            { "type": "roll_dice", "min": 1, "max": 20, "currency": "points" }
          ]
        }
      ]
    },
    {
      "id": "magic_shop",
      "title": "Magic Shop (Tags Test)",
      "page": 0,
      "coords": { "x": 50, "y": 220, "w": 1200, "h": 200 },
      "items": [
        {
          "id": "fire_scroll",
          "title": "Fire Scroll",
          "tags": ["magic", "fire"],
          "description": "Tags: Magic, Fire\nCost: 10 (5 with Ring)",
          "coords": { "x": 50, "y": 250, "w": 350, "h": 150 },
          "cost": [{ "currency": "points", "value": -10 }]
        },
        {
          "id": "ice_scroll",
          "title": "Ice Scroll",
          "tags": ["magic", "ice"],
          "description": "Tags: Magic, Ice\nCost: 10 (5 with Ring)",
          "coords": { "x": 420, "y": 250, "w": 350, "h": 150 },
          "cost": [{ "currency": "points", "value": -10 }]
        },
        {
          "id": "master_spell",
          "title": "Master Spell",
          "description": "Requires 2 items with 'magic' tag.",
          "coords": { "x": 790, "y": 250, "w": 350, "h": 150 },
          "cost": [{ "currency": "points", "value": -20 }],
          "requirements": ["count.tag('magic') >= 2"]
        }
      ]
    },
    {
      "id": "max_choices",
      "title": "Choose Only 1 (Limit Test)",
      "page": 0,
      "coords": { "x": 1310, "y": 220, "w": 560, "h": 640 },
      "rules": { "max_choices": 1 },
      "items": [
        {
          "id": "choice_a",
          "title": "Choice A",
          "coords": { "x": 1330, "y": 250, "w": 520, "h": 150 },
          "cost": []
        },
        {
          "id": "choice_b",
          "title": "Choice B",
          "coords": { "x": 1330, "y": 420, "w": 520, "h": 150 },
          "cost": []
        },
        {
          "id": "choice_c",
          "title": "Choice C",
          "coords": { "x": 1330, "y": 590, "w": 520, "h": 150 },
          "cost": []
        }
      ]
    },
    {
      "id": "paid_items",
      "title": "Misc Items",
      "page": 0,
      "coords": { "x": 50, "y": 440, "w": 1200, "h": 200 },
      "items": [
        {
          "id": "cheap",
          "title": "Cheap Item",
          "coords": { "x": 50, "y": 470, "w": 350, "h": 150 },
          "cost": [{ "currency": "points", "value": -1 }]
        }
      ]
    }
  ]
}
</file>

<file path="docs/llm-guide.md">
# LLM Guide: CYOA Extraction

## Your Task
Extract game structure from CYOA images into JSON configuration.

## Output Format

```json
{
  "meta": {
    "title": "Game Title",
    "pages": ["page1.png", "page2.png"]
  },
  "points": [
    {
      "id": "points",
      "name": "Points",
      "start": 10
    }
  ],
  "groups": [
    {
      "id": "group_id",
      "title": "Group Title",
      "description": "...",
      "page": 0,
      "coords": {"x": 10, "y": 20, "w": 30, "h": 40},
      "rules": {
        "max_choices": 3,
        "budget": {
          "currency": "points",
          "amount": 5,
          "name": "Free Picks"
        }
      },
      "items": [...]
    }
  ]
}
```

## Item Structure

```json
{
  "id": "unique_id",
  "title": "Item Name",
  "description": "Full text",
  "coords": {"x": 100, "y": 200, "w": 300, "h": 400},
  "cost": [
    {
      "currency": "points",
      "value": -5,
      "formula": "count.this_group > 2 ? -2 : 0"
    }
  ],
  "requirements": [
    "other_item_id",
    "item_a || item_b",
    "count.companions >= 3"
  ],
  "incompatible": ["opposite_item"]
}
```

## Pattern Recognition

| Image Text | JSON Rule |
|------------|-----------|
| "Costs 5 points" | `"cost": [{"currency": "points", "value": -5}]` |
| "+10 gold" | `"cost": [{"currency": "gold", "value": 10}]` |
| "Requires: Magic" | `"requirements": ["magic"]` |
| "Choose up to 3" | `"rules": {"max_choices": 3}` |
| "3 free picks" | `"rules": {"budget": {"currency": "points", "amount": 3}}` |
| "Incompatible with Fire" | `"incompatible": ["fire"]` |
| "Take up to 3 times" | `"max_quantity": 3` |
| "+2 Spell Slots" | `"effects": [{"type": "modify_group_limit", "group_id": "spells", "value": 2}]` |
| "Free Sword included" | `"effects": [{"type": "force_selection", "target_id": "sword"}]` |


## Coordinate System

Use **pixels from top-left** corner:
```json
{
  "x": 100,    // left edge
  "y": 200,    // top edge  
  "w": 300,    // width
  "h": 400     // height
}
```

System auto-converts to percentages.

## Common Mistakes

‚ùå **Wrong:**
```json
{
  "cost": [{"currency": "points", "value": 5}]  // Positive = gain!
}
```

‚úÖ **Correct:**
```json
{
  "cost": [{"currency": "points", "value": -5}]  // Negative = spend
}
```

---

‚ùå **Wrong:**
```json
{
  "requirements": ["item_a AND item_b"]  // Wrong syntax
}
```

‚úÖ **Correct:**
```json
{
  "requirements": ["item_a && item_b"]  // Use &&
}
```




## Tag System
You can extract "Tags" from item descriptions or categories if they are used in the game. 

**Example Extraction:**
*Image Text:* "Fireball (Spell). blasts enemies with fire."
*JSON:*
```json
{
  "id": "fireball",
  "title": "Fireball",
  "tags": ["spell", "fire", "magic"], // Infer tags from context!
  ...
}
```

## Output Format

```json
{
  "meta": { "title": "Game Title", "pages": ["page1.png"] },
  "points": [{ "id": "points", "name": "Points", "start": 100 }],
  "groups": [
    {
      "id": "group_id",
      "title": "Group Title",
      "items": [
        {
          "id": "item_id",
          "title": "Item Name",
          "tags": ["tag1", "tag2"],  <-- TAGS
          "cost": [{"currency": "points", "value": -5}],
          "requirements": ["count.tag('tag1') >= 3"],
          "effects": []
        }
      ]
    }
  ]
}
```
  
## Pattern Recognition Guide

### 1. Requirements
| Text Pattern | JSON Rule |
|--------------|-----------|
| "Requires 3 Magic items" | `"requirements": ["count.tag('magic') >= 3"]` |
| "Need any Weapon" | `"requirements": ["count.tag('weapon') > 0"]` |
| "Requires Fireball" | `"requirements": ["fireball"]` |

### 2. Discounts (Global Modifiers)
| Text Pattern | JSON Effect |
|--------------|-------------|
| "Magic items cost 50% less" | `{"type": "modify_cost", "tag": "magic", "mode": "multiply", "value": 0.5}` |
| "Swords cost -2 points" | `{"type": "modify_cost", "tag": "sword", "mode": "add", "value": 2}` |
| "Fire spells are free" | `{"type": "modify_cost", "tag": "fire", "mode": "multiply", "value": 0}` |

### 3. Group Limits
| Text Pattern | JSON Effect |
|--------------|-------------|
| "+2 Spell Slots" | `{"type": "modify_group_limit", "group_id": "spells", "value": 2}` |
| "Can pick 1 extra Companion" | `{"type": "modify_group_limit", "group_id": "companions", "value": 1}` |

## Common Mistakes to AVOID

‚ùå **Wrong:** `requirements: ["item1 || item2 || item3"]` (Hardcoding IDs)
‚úÖ **Correct:** `requirements: ["count.tag('magic') > 0"]` (Using Tags)

‚ùå **Wrong:** `value: 5` for cost (This adds points)
‚úÖ **Correct:** `value: -5` for cost (This spends points)

‚ùå **Wrong:** `value: -0.5` for discount multiplier (Result becomes negative)
‚úÖ **Correct:** `value: 0.5` for discount (Multiplies cost by 0.5)
</file>

<file path="docs/rule-catalog.md">
### `docs/rule-catalog.md`

# CYOA Rule Catalog for LLM

## Overview
This catalog defines all available game mechanics that can be extracted from CYOA images.
Each rule is declarative and composable.

---

## ü™ô Currency System

### Basic Currency
```json
{
  "points": [
    {
      "id": "points",           // unique identifier
      "name": "Points",          // display name
      "start": 100,              // starting amount
      "min": 0,                  // optional minimum (default: -Infinity)
      "max": null                // optional maximum
    }
  ]
}
```

**Examples from images:**
- "You have 10 points to spend"
- "Starting credits: 50"
- "Budget: 7 Sparks of Power"

---

## üí∞ Cost Rules

### Rule: `simple_cost`
Item costs a fixed amount.

```json
{
  "cost": [
    {
      "currency": "points",
      "value": -5              // negative = spend, positive = gain
    }
  ]
}
```

**Pattern recognition:**
- "Costs 5 points"
- "-3 gold"
- "Price: 2 sparks"

---

### Rule: `conditional_cost`
Cost changes based on conditions.

```json
{
  "cost": [
    {
      "currency": "points",
      "base": -5,
      "formula": "selected.length > 3 ? -2 : 0"
    }
  ]
}
```

**Examples:**
- "Costs 5 points, +2 if you have more than 3 perks"
- "First pick free, then 3 points each"

**Formula syntax:**
```javascript
// Available variables:
selected.length        // number of selected items in this group
selected.has("id")     // check if item is selected
currency.points        // current currency value
count.groupId          // items selected in specific group

// Examples:
"count.companions > 2 ? -5 : -3"
"selected.length * -2"
"currency.points < 10 ? -1 : -3"
```

---

## üîí Requirement Rules

### Rule: `requires_item`
Requires another item to be selected.

```json
{
  "requirements": ["item_id"]
}
```

**Patterns:**
- "Requires: Magic Affinity"
- "Must have: Dragon Bond"
- "Prerequisite: Arcane Knowledge"

---

### Rule: `requires_any`
Requires at least one from a list.

```json
{
  "requirements": [
    "item_a || item_b || item_c"
  ]
}
```

**Patterns:**
- "Requires one of: Fire, Ice, Lightning"
- "Must have at least one combat ability"

---

### Rule: `requires_all`
Requires all items from a list.

```json
{
  "requirements": [
    "item_a && item_b"
  ]
}
```

**Patterns:**
- "Requires both: Sword Mastery AND Shield Training"

---

### Rule: `requires_count`
Requires a certain number of items from a group.

```json
{
  "requirements": [
    "count.perks >= 3"
  ]
}
```

**Patterns:**
- "Available after selecting 3 perks"
- "Unlock at 5+ companions"

---

### Rule: `incompatible`
Cannot be selected together.

```json
{
  "incompatible": ["item_id"]
}
```

**Patterns:**
- "Incompatible with: X"
- "Cannot take with: Y"
- "Mutually exclusive"

---

## üìä Group Rules

### Rule: `max_choices`
Limit selections in a group.

```json
{
  "rules": {
    "max_choices": 3,
    "min_choices": 1          // optional
  }
}
```

**Patterns:**
- "Choose up to 3"
- "Pick 1-3 options"
- "Select exactly 2"

---

### Rule: `pick_style`
How selections work.

```json
{
  "rules": {
    "pick_style": "radio"     // only one at a time
    // or
    "pick_style": "checkbox"  // multiple allowed (default)
  }
}
```

---

### Rule: `local_budget`
Group has its own point pool.

```json
{
  "rules": {
    "budget": {
      "currency": "points",
      "amount": 10,
      "name": "Perk Budget",
      "applies_to": ["group_a", "group_b"]  // optional: share budget
    }
  }
}
```

**Patterns:**
- "This section has 5 free picks"
- "10 point budget for powers"
- "Shared pool: 8 choices across items and companions"

---

### Rule: `free_first_n`
First N selections are free.

```json
{
  "rules": {
    "free_first": 2
  }
}
```

**Patterns:**
- "First 2 picks free"
- "One free choice included"

Formula equivalent:
```json
{
  "cost": [{
    "currency": "points",
    "base": -3,
    "formula": "count.this_group < 2 ? 3 : 0"
  }]
}
```

---

## üé≤ Advanced Rules

### Rule: `scaling_cost`
Cost increases with selections.

```json
{
  "cost": [{
    "currency": "points",
    "formula": "-(2 ** count.this_group)"  // 2, 4, 8, 16...
  }]
}
```

**Patterns:**
- "Each additional costs double"
- "1st: 1 point, 2nd: 2 points, 3rd: 4 points..."

---

### Rule: `discount`
Reduce cost based on conditions.

```json
{
  "cost": [{
    "currency": "points",
    "base": -10,
    "formula": "selected.has('merchant_perk') ? 5 : 0"
  }]
}
```

**Patterns:**
- "50% off if you have Merchant"
- "Free with Noble background"

---

### Rule: `toggle_effect`
Selecting changes other items.

```json
{
  "effects": [
    {
      "type": "modify_currency",
      "currency": "mana",
      "value": 100
    },
    {
      "type": "unlock_item",
      "target": "secret_path"
    }
  ]
}
```

---

## üîÑ Dynamic Rules (Custom JS)

For unique mechanics not covered above:

```json
{
  "custom_rule": {
    "type": "javascript",
    "code": "return selected.has('dragon') && currency.gold >= 1000;"
  }
}
```

**Use sparingly!** Try to compose existing rules first.

---

## üìù LLM Extraction Instructions

When analyzing a CYOA image:

1. **Identify currencies:**
   - Look for: "points", "budget", "credits", "gold"
   - Extract starting amounts

2. **Identify groups:**
   - Usually separated by headers or visual sections
   - Extract title and description

3. **For each item/card:**
   - Extract: title, description, position
   - Look for cost indicators (-, Cost:, Price:)
   - Find requirements (Requires:, Needs:, Must have:)
   - Check for incompatibilities (Incompatible:, Cannot:)

4. **For group rules:**
   - "Choose X" ‚Üí `max_choices`
   - "Pick up to X" ‚Üí `max_choices`
   - "X free picks" ‚Üí `budget` or `free_first`

5. **Output format:**
   ```json
   {
     "item_id": {
       "title": "...",
       "cost": [...],
       "requirements": [...],
       "incompatible": [...]
     }
   }
   ```

---

## ‚ö†Ô∏è Common Patterns

| Text Pattern | Rule | JSON |
|--------------|------|------|
| "Costs 5 points" | simple_cost | `"cost": [{"currency": "points", "value": -5}]` |
| "Requires: Fire Magic" | requires_item | `"requirements": ["fire_magic"]` |
| "Choose 3" | max_choices | `"rules": {"max_choices": 3}` |
| "Incompatible with Ice" | incompatible | `"incompatible": ["ice_magic"]` |
| "First pick free" | free_first | `"rules": {"free_first": 1}` |
| "+10 mana" | gain_currency | `"cost": [{"currency": "mana", "value": 10}]` |

---

## üß™ Validation

Always ensure:
- [ ] All referenced IDs exist
- [ ] Costs are negative for spending
- [ ] Requirements don't create impossible loops
- [ ] Formulas are valid JavaScript
- [ ] Coordinates are within image bounds

 
 
## üì¶ Multi-Select & Quantity

Allow selecting an item multiple times.

### Rule: `max_quantity`
```json
{
  "max_quantity": 5,
  "cost": [{"currency": "points", "value": -2}]
}
```
**Behavior:**
- UI shows `+` and `-` buttons
- Cost is automatically multiplied (e.g., buying 3 costs 6 points)
- Formulas can use `qty('item_id')` to get the count.

**Patterns:**
- "Can be taken up to 3 times"
- "Buy multiple potions"
- "Each purchase costs X"

---

## ‚ú® Effects System

Items can actively modify the game rules or other items.

### Effect: `modify_group_limit`
Increases (or decreases) the number of allowed choices in a group.

```json
{
  "effects": [
    {
      "type": "modify_group_limit",
      "group_id": "spells_section",
      "value": 2
    }
  ]
}
```
*Note: If `max_quantity` > 1, the effect multiplies by the quantity unless `"once": true` is added.*

**Patterns:**
- "Unlock +2 spell slots"
- "Allows one extra companion"
- "Backpack: Increases inventory capacity"

---

### Effect: `force_selection`
Automatically selects another item.

```json
{
  "effects": [
    {
      "type": "force_selection",
      "target_id": "basic_sword"
    }
  ]
}
```

**Patterns:**
- "Comes with a free sword"
- "Knight class includes heavy armor"

---

### Effect: `set_value`
Sets a currency/variable to a specific number (ignoring calculations).

```json
{
  "effects": [
    {
      "type": "set_value",
      "currency": "strength",
      "value": 10
    }
  ]
}
```

**Patterns:**
- "Sets your Strength to 10"
- "Resets Magic to 0"
```





## üè∑Ô∏è Tag System  
Tags are the primary way to categorize items for requirements and discounts.
Items can have multiple tags.

```json
{
  "id": "fire_sword",
  "title": "Flaming Sword",
  "tags": ["weapon", "fire", "magic", "metal"]
}
```

---

## üîí Requirements with Tags

### Rule: `requires_tag_count`
Requires X items with a specific tag.

```json
{
  "requirements": [
    "count.tag('magic') >= 3",
    "count.tag('weapon') > 0"
  ]
}
```

**Patterns:**
- "Requires 3 Magic items"
- "Need at least one Weapon"
- "Unlock after picking 5 Fire spells"

---

## ü™ô Global Modifiers (Discounts)

### Rule: `modify_cost`
Changes the cost of OTHER items based on tags or groups.

**Percentage Discount (Multiply):**
```json
{
  "effects": [
    {
      "type": "modify_cost",
      "tag": "magic",           // Target items with this tag
      "mode": "multiply",       // Multiplication mode
      "value": 0.5              // 0.5 = 50% cost (50% discount)
    }
  ]
}
```
*Note: `value` is the multiplier. 0.5 means "half price".*

**Flat Discount (Add):**
```json
{
  "effects": [
    {
      "type": "modify_cost",
      "tag": "weapon",
      "mode": "add",
      "value": 2               // Adds +2 to the cost (Reduces spending)
    }
  ]
}
```
*Note: Since costs are usually negative (e.g. -10), adding +2 makes it -8 (cheaper).*

**Patterns:**
- "All Magic items cost 50% less"
- "Swords are 2 points cheaper"
- "Fire spells are free" (`mode: multiply, value: 0`)

---

## üí∞ Basic Cost & Currency

### Rule: `simple_cost`
```json
{
  "cost": [{"currency": "points", "value": -5}]
}
```

### Rule: `max_quantity`
Allow selecting multiple times.
```json
{
  "max_quantity": 3
}
```

---

## üìä Group Rules

### Rule: `max_choices`
```json
{
  "rules": {
    "max_choices": 1  // Radio button behavior
  }
}
```

### Rule: `budget`
```json
{
  "rules": {
    "budget": {
      "currency": "points",
      "amount": 5,
      "name": "Free Picks"
    }
  }
}
```

---

## ‚ú® Other Effects

### Rule: `modify_group_limit`
Increases allowed choices in another group.
```json
{
  "effects": [
    {
      "type": "modify_group_limit",
      "group_id": "spells",
      "value": 2
    }
  ]
}
```

### Rule: `force_selection`
```json
{
  "effects": [
    {
      "type": "force_selection",
      "target_id": "basic_sword"
    }
  ]
}
```
</file>

<file path="src/main.js">
/**
 * CYOA Interactive System - Main Entry Point
 * 
 * This file initializes the entire system:
 * 1. Loads config from JSON
 * 2. Creates game engine
 * 3. Creates UI renderer
 * 4. Sets up controls
 */
 

import { GameEngine } from './core/engine.js';
import { UIRenderer } from './ui/renderer.js';
import { ControlPanel } from './ui/controls.js';

// Global state
let engine, renderer, controls;

async function init() {
    console.log('üöÄ Starting CYOA Interactive System...');
    
    try {
        const response = await fetch('config/test_config.json');
        
        if (!response.ok) {
            throw new Error(`Config not found (${response.status})`);
        }
        
        const config = await response.json();
        console.log('‚úÖ Config loaded:', config.meta?.title || 'Untitled');

        engine = new GameEngine(config);
        renderer = new UIRenderer(engine);
        controls = new ControlPanel(engine, renderer);

        await renderer.renderAll();
         
        engine.recalculate();

        const loading = document.getElementById('loading');
        if (loading) {
            loading.classList.add('hidden');
            setTimeout(() => loading.remove(), 300);
        }

        console.log('‚ú® CYOA loaded successfully!');
        console.log('üí° Tip: Click üêû Debug to enter edit mode');

    } catch (error) {
        console.error('‚ùå Initialization failed:', error);
        
        const loading = document.getElementById('loading');
        if (loading) {
            loading.innerHTML = `
                <div style="color: #ff4444;">
                    ‚ùå Failed to load CYOA<br>
                    <small>${error.message}</small><br><br>
                    <small style="color: #888;">
                        Check console (F12) for details<br>
                        Make sure you're running via HTTP server
                    </small>
                </div>
            `;
        }
    }
}

init();

// Export for debugging via browser console
window.CYOA = {
    get engine() { return engine; },
    get renderer() { return renderer; },
    get controls() { return controls; },
    get editor() { return controls?.editor; },
    get state() { return engine?.state; },
    get config() { return engine?.config; }
};

console.log('üí° Debug commands available:');
console.log('  CYOA.engine.select("item_id")  - Select an item');
console.log('  CYOA.engine.reset()            - Reset everything');
console.log('  CYOA.editor.enable()           - Enable editor');
console.log('  CYOA.state                     - View current state');
</file>

<file path="src/core/effects.js">
/**
 * Effect Processor - Handles active card effects
 */

export class EffectProcessor {
    constructor(engine) {
        this.engine = engine;
    }

    /**
     * Apply effects from all selected items
     */
    applyAll() {
        this.engine.restoreDefaults();

        // Iterate over selected items and apply their effects
        for (const [itemId, qty] of this.engine.state.selected) {
            const item = this.engine.findItem(itemId);
            if (!item || !item.effects) continue;

            for (const effect of item.effects) {
                this.process(effect, item, qty);
            }
        }
    }

    process(effect, sourceItem, qty) {
        switch (effect.type) {
            
            case 'modify_group_limit':
                this.applyGroupLimitMod(effect, qty);
                break;

            case 'force_selection':
                this.applyForceSelection(effect, qty);
                break;

            case 'set_value':
                this.applySetValue(effect, qty);
                break;
            
            case 'modify_cost':
                this.applyModifyCost(effect, qty);
                break;
            
            // NEW: Roll Dice Logic (Applying the result)
            case 'roll_dice':
                this.applyRollDice(effect, sourceItem, qty);
                break;

            default:
                console.warn(`Unknown effect type: ${effect.type}`);
        }
    }

    // ==================== HANDLERS ====================

    applyGroupLimitMod(effect, qty) {
        const group = this.engine.config.groups.find(g => g.id === effect.group_id);
        if (!group || !group.rules) return;

        let value = effect.value || 0;
        if (!effect.once) {
            value *= qty;
        }

        if (group.rules.max_choices !== undefined) {
            group.rules.max_choices += value;
        }
    }

    applyForceSelection(effect, qty) {
        const targetId = effect.target_id;
        const currentQty = this.engine.state.selected.get(targetId) || 0;
        
        if (currentQty === 0) {
            this.engine.state.selected.set(targetId, 1);
            console.log(`‚ö° Effect forced selection: ${targetId}`);
        }
    }

    applySetValue(effect, qty) {
        const currency = effect.currency;
        const value = effect.value;
        this.engine.state.currencies[currency] = value;
    }

    applyModifyCost(effect, qty) {
        for (let i = 0; i < qty; i++) {
            this.engine.modifiers.cost.push({
                tag: effect.tag,
                groupId: effect.group_id,
                currency: effect.currency,
                mode: effect.mode || 'add',
                value: effect.value
            });
            if (effect.once) break;
        }
    }

    // NEW: Apply the pre-rolled value to the currency
    applyRollDice(effect, sourceItem, qty) {
        if (!effect.currency) return;
        
        // Retrieve the frozen result from state
        const rolledValue = this.engine.state.rollResults.get(sourceItem.id);
        
        // If (for some reason) it wasn't rolled yet, we skip adding (should have happened in engine.select)
        if (rolledValue !== undefined) {
            if (this.engine.state.currencies[effect.currency] !== undefined) {
                // If quantity > 1, do we multiply the result?
                // Usually random rolls are "Unique", but if allowed multiple, 
                // currently logic uses ONE roll for all copies. 
                // To support multiple separate rolls, state structure would need to change.
                // Assuming multiply for now.
                this.engine.state.currencies[effect.currency] += (rolledValue * qty);
            }
        }
    }
}
</file>

<file path="src/core/engine.js">
/**
 * Game Engine - Core game logic and state management
 */

import { RuleEvaluator } from './rules.js';
import { GameState } from './state.js';
import { EffectProcessor } from './effects.js';

export class GameEngine {
    constructor(config) {
        this.config = config;
        this.state = new GameState(config);
        this.rules = new RuleEvaluator(this);
        this.effects = new EffectProcessor(this);
        this.listeners = {};
        
        this.modifiers = {
            cost: [] 
        };
        
        this.defaults = {
            groupRules: {}
        };
        this.initDefaults();

        console.log('üéÆ Engine initialized (With Dice Logic)');
    }

    initDefaults() {
        this.config.groups.forEach(g => {
            if (g.rules) {
                this.defaults.groupRules[g.id] = JSON.parse(JSON.stringify(g.rules));
            }
        });
    }

    restoreDefaults() {
        this.config.groups.forEach(g => {
            if (this.defaults.groupRules[g.id]) {
                g.rules = JSON.parse(JSON.stringify(this.defaults.groupRules[g.id]));
            }
        });
    }

    // ==================== SELECTION ====================

    select(itemId) {
        const item = this.findItem(itemId);
        if (!item) return false;

        const group = this.findGroupForItem(itemId);
        if (!group) return false;

        // Check requirements
        if (!this.canSelect(item, group)) return false;

        const currentQty = this.state.selected.get(itemId) || 0;
        const maxQty = item.max_quantity || 1;

        if (currentQty >= maxQty) return false;

        // Radio logic (Max choices)
        if (currentQty === 0 && group.rules?.max_choices === 1) {
            group.items.forEach(i => {
                if (this.state.selected.has(i.id) && i.id !== itemId) {
                    this.state.selected.delete(i.id);
                }
            });
        } else if (group.rules?.max_choices) {
            const totalInGroup = this.getGroupQty(group);
            if (totalInGroup >= group.rules.max_choices) {
                console.log(`Max choices reached in ${group.id} (Limit: ${group.rules.max_choices})`);
                return false;
            }
        }

        // === RANDOM ROLL LOGIC ===
        // If this item has a roll effect, we determine the result NOW.
        // We only generate if it hasn't been generated before for this ID.
        // This prevents re-rolling by toggling.
        if (item.effects) {
            const rollEffect = item.effects.find(e => e.type === 'roll_dice');
            if (rollEffect && !this.state.rollResults.has(itemId)) {
                const min = parseInt(rollEffect.min) || 1;
                const max = parseInt(rollEffect.max) || 6;
                // Random integer between min and max (inclusive)
                const result = Math.floor(Math.random() * (max - min + 1)) + min;
                
                this.state.rollResults.set(itemId, result);
                console.log(`üé≤ Rolled for ${itemId}: ${result}`);
            }
        }

        this.state.selected.set(itemId, currentQty + 1);
        this.recalculate(); 
        this.emit('selection', { itemId, selected: true, qty: currentQty + 1 });
        return true;
    }

    deselect(itemId) {
        if (!this.state.selected.has(itemId)) return false;

        const currentQty = this.state.selected.get(itemId);
        
        if (currentQty > 1) {
             this.state.selected.set(itemId, currentQty - 1);
        } else {
             this.state.selected.delete(itemId);
        }

        this.recalculate();
        this.emit('selection', { itemId, selected: false, qty: currentQty - 1 });
        return true;
    }

    toggle(itemId) {
        if (this.state.selected.has(itemId)) {
            return this.deselect(itemId);
        } else {
            return this.select(itemId);
        }
    }

    // ==================== VALIDATION ====================

    canSelect(item, group) {
        if (!this.rules.checkRequirements(item)) return false;
        if (!this.rules.checkIncompatible(item)) return false;
        return true;
    }

    // ==================== CALCULATION ====================

    recalculate() {
        this.cleanupInvalidSelections();
        this.state.resetCurrencies();
        this.modifiers = { cost: [] };

        // Apply Effects (Populates modifiers, applies immediate value changes)
        this.effects.applyAll();

        // Calculate Costs with modifiers
        const groupDeltas = this.calculateGroupDeltas();
        
        this.applyBudgets(groupDeltas);
        this.applyDeltas(groupDeltas);

        this.emit('recalculate', { state: this.state });
    }

    cleanupInvalidSelections() {
        for (const itemId of this.state.selected.keys()) {
            const item = this.findItem(itemId);
            const group = this.findGroupForItem(itemId);
            if (!item || !this.canSelect(item, group)) {
                this.state.selected.delete(itemId);
            }
        }
    }

    calculateGroupDeltas() {
        const deltas = {};
        for (const itemId of this.state.selected.keys()) {
            const item = this.findItem(itemId);
            const group = this.findGroupForItem(itemId);
            const qty = this.state.selected.get(itemId);
            
            if (!item?.cost) continue;
            if (!deltas[group.id]) deltas[group.id] = {};

            for (const cost of item.cost) {
                const unitValue = this.rules.evaluateCost(cost, item, group);
                const currencyId = cost.currency;
                if (!deltas[group.id][currencyId]) deltas[group.id][currencyId] = 0;
                deltas[group.id][currencyId] += (unitValue * qty);
            }
        }
        return deltas;
    }

    applyBudgets(groupDeltas) {
        for (const group of this.config.groups) {
            if (!group.rules?.budget) continue;
            const budget = group.rules.budget;
            const targetGroups = [group.id, ...(budget.applies_to || [])];

            let totalSpent = 0;
            for (const gid of targetGroups) {
                if (groupDeltas[gid]?.[budget.currency] < 0) {
                    totalSpent += Math.abs(groupDeltas[gid][budget.currency]);
                }
            }

            const covered = Math.min(totalSpent, budget.amount);
            let remaining = covered;

            for (const gid of targetGroups) {
                if (remaining <= 0) break;
                if (groupDeltas[gid]?.[budget.currency] < 0) {
                    const debt = Math.abs(groupDeltas[gid][budget.currency]);
                    const pay = Math.min(debt, remaining);
                    groupDeltas[gid][budget.currency] += pay;
                    remaining -= pay;
                }
            }

            this.state.budgets[group.id] = {
                total: budget.amount,
                used: covered,
                remaining: budget.amount - covered
            };
        }
    }

    applyDeltas(groupDeltas) {
        for (const groupId in groupDeltas) {
            for (const currencyId in groupDeltas[groupId]) {
                if (this.state.currencies[currencyId] !== undefined) {
                    this.state.currencies[currencyId] += groupDeltas[groupId][currencyId];
                }
            }
        }
    }

    // ==================== HELPERS ====================

    findItem(itemId) {
        for (const group of this.config.groups) {
            const item = group.items.find(i => i.id === itemId);
            if (item) return item;
        }
        return null;
    }

    findGroupForItem(itemId) {
        for (const group of this.config.groups) {
            if (group.items.find(i => i.id === itemId)) {
                return group;
            }
        }
        return null;
    }

    getSelectedInGroup(group) {
        return group.items.filter(i => this.state.selected.has(i.id));
    }

    getGroupQty(group) {
        let total = 0;
        group.items.forEach(i => {
            total += (this.state.selected.get(i.id) || 0);
        });
        return total;
    }

    on(event, callback) {
        if (!this.listeners[event]) this.listeners[event] = [];
        this.listeners[event].push(callback);
    }

    emit(event, data) {
        if (this.listeners[event]) this.listeners[event].forEach(cb => cb(data));
    }

    reset() {
        this.state.reset();
        this.restoreDefaults(); 
        this.recalculate();
        this.emit('reset');
    }
}
</file>

<file path="src/core/rules.js">

/**
 * Rule Evaluator - Handles requirements, costs, and formulas
 */

export class RuleEvaluator {
    constructor(engine) {
        this.engine = engine;
    }

    // ==================== REQUIREMENTS ====================

    checkRequirements(item) {
        if (!item.requirements) return true;

        for (const req of item.requirements) {
            if (!this.evaluateRequirement(req, item)) {
                return false;
            }
        }
        return true;
    }

    evaluateRequirement(req, item) {
        // Complex formula
        if (req.includes('||') || req.includes('&&') || req.includes('(')) {
            return this.evaluateFormula(req, item, null);
        }

        // Negation: !item_id
        if (req.startsWith('!')) {
            const targetId = req.slice(1).trim();
            return !this.engine.state.selected.has(targetId);
        }

        // Simple: item_id
        return this.engine.state.selected.has(req.trim());
    }

    // ==================== INCOMPATIBLE ====================

    checkIncompatible(item) {
        if (!item.incompatible) return true;

        for (const badId of item.incompatible) {
            if (this.engine.state.selected.has(badId)) {
                return false;
            }
        }
        return true;
    }

    // ==================== COST EVALUATION ====================

    evaluateCost(cost, item, group) {
        const { value } = this.calculateCostWithDetails(cost, item, group);
        return value;
    }

    /**
     * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ü–µ–Ω—É –ò —Å–ø–∏—Å–æ–∫ –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã—Ö –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤ –¥–ª—è UI
     */
    getCostBreakdown(cost, item, group) {
        return this.calculateCostWithDetails(cost, item, group);
    }

    calculateCostWithDetails(cost, item, group) {
        // 1. Base Calc
        let value = cost.value || cost.base || 0;
        if (cost.formula) value += this.evaluateFormula(cost.formula, item, group);
        if (cost.condition) value += this.evaluateFormula(cost.condition, item, group);

        const modifiersText = [];

        // 2. Apply Modifiers
        if (this.engine.modifiers.cost.length > 0) {
            // –§–∏–ª—å—Ç—Ä—É–µ–º –ø—Ä–∏–º–µ–Ω–∏–º—ã–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã
            const applicable = this.engine.modifiers.cost.filter(mod => {
                if (mod.currency && mod.currency !== cost.currency) return false;
                if (mod.groupId && group.id !== mod.groupId) return false;
                if (mod.tag && (!item.tags || !item.tags.includes(mod.tag))) return false;
                return true;
            });

            // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ "–í –ø–æ–ª—å–∑—É –∏–≥—Ä–æ–∫–∞": –°–Ω–∞—á–∞–ª–∞ —É–º–Ω–æ–∂–µ–Ω–∏–µ, –ø–æ—Ç–æ–º —Å–ª–æ–∂–µ–Ω–∏–µ
            // set - —Å–∞–º—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π, –æ–Ω –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –≤—Å—ë
            const setters = applicable.filter(m => m.mode === 'set');
            const multipliers = applicable.filter(m => m.mode === 'multiply');
            const adders = applicable.filter(m => m.mode === 'add' || !m.mode);

            // 1. Set (–µ—Å–ª–∏ –µ—Å—Ç—å, –æ—Å—Ç–∞–ª—å–Ω–æ–µ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º, –ª–∏–±–æ –ø—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–≤–µ—Ä—Ö - –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –ª–æ–≥–∏–∫–∏)
            // –û–±—ã—á–Ω–æ set —Å—Ç–∞–≤–∏—Ç –±–∞–∑—É. –ü—É—Å—Ç—å –±—É–¥–µ—Ç —Ç–∞–∫.
            if (setters.length > 0) {
                const lastSet = setters[setters.length - 1];
                value = lastSet.value;
                modifiersText.push(`= ${value}`);
            }

            // 2. Multipliers (–°–∫–∏–¥–∫–∏ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö)
            // –°–∫–ª–∞–¥—ã–≤–∞–µ–º –º–Ω–æ–∂–∏—Ç–µ–ª–∏? –ò–ª–∏ –ø–µ—Ä–µ–º–Ω–æ–∂–∞–µ–º? –û–±—ã—á–Ω–æ –ø–µ—Ä–µ–º–Ω–æ–∂–∞–µ–º (0.5 * 0.5 = 0.25 –∏—Ç–æ–≥–æ–≤–∞—è)
            for (const mod of multipliers) {
                value *= mod.value;
                
                // –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç: 0.5 -> -50%, 1.5 -> +50%
                const percent = Math.round((1 - mod.value) * 100);
                if (percent > 0) modifiersText.push(`-${percent}%`); // –°–∫–∏–¥–∫–∞
                else modifiersText.push(`+${Math.abs(percent)}%`);   // –ù–∞—Ü–µ–Ω–∫–∞
            }

            // 3. Adders (–ü–ª–æ—Å–∫–∏–µ —Å–∫–∏–¥–∫–∏)
            for (const mod of adders) {
                value += mod.value;
                
                // –ï—Å–ª–∏ value –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ (—Ü–µ–Ω–∞), —Ç–æ +value —ç—Ç–æ —Å–∫–∏–¥–∫–∞.
                // –ü–∏—à–µ–º –∫–∞–∫ –µ—Å—Ç—å: "+5" –∏–ª–∏ "-5"
                const sign = mod.value > 0 ? '+' : '';
                modifiersText.push(`${sign}${mod.value}`);
            }
        }

        return { 
            value: Math.round(value), 
            modifiers: modifiersText 
        };
    }

    applyCostModifiers(baseValue, item, group, currency) {
        let finalValue = baseValue;

        // Iterate through all active modifiers
        for (const mod of this.engine.modifiers.cost) {
            let apply = true;

            // Filter: Currency
            if (mod.currency && mod.currency !== currency) apply = false;

            // Filter: Group ID
            if (apply && mod.groupId && group.id !== mod.groupId) apply = false;

            // Filter: Tag
            if (apply && mod.tag) {
                if (!item.tags || !item.tags.includes(mod.tag)) apply = false;
            }

            if (apply) {
                if (mod.mode === 'multiply') {
                    // e.g. 50% discount: value * 0.5
                    finalValue *= mod.value;
                } else if (mod.mode === 'add') {
                    // e.g. -2 discount: -10 becomes -8. 
                    // Note: Since costs are usually negative (-10), adding +2 reduces the cost.
                    finalValue += mod.value;
                } else if (mod.mode === 'set') {
                    finalValue = mod.value;
                }
            }
        }
        
        return Math.round(finalValue);
    }

    // ==================== FORMULA EVALUATION ====================

    evaluateFormula(formula, item, group) {
        try {
            const context = this.createFormulaContext(item, group);
            const func = new Function(...Object.keys(context), `return ${formula};`);
            return func(...Object.values(context));
        } catch (error) {
            console.error('Formula error:', formula, error);
            return 0;
        }
    }

    createFormulaContext(item, group) {
        const state = this.engine.state;

        return {
            has: (id) => state.selected.has(id),
            qty: (id) => state.selected.get(id) || 0,
            
            selected: {
                has: (id) => state.selected.has(id),
                get: (id) => state.selected.get(id) || 0,
                length: state.selected.size 
            },

            currency: { ...state.currencies },

            // Count helpers + TAGS
            count: {
                ...this.createCountHelper(group),
                // count.tag('magic') -> returns total quantity of items with this tag
                tag: (tagName) => {
                    let total = 0;
                    for (const [itemId, qty] of state.selected) {
                        const i = this.engine.findItem(itemId);
                        if (i && i.tags && i.tags.includes(tagName)) {
                            total += qty;
                        }
                    }
                    return total;
                }
            },

            this_group: group ? this.engine.getGroupQty(group) : 0,

            Math: Math
        };
    }

    createCountHelper(currentGroup) {
        const counts = {};
        for (const group of this.engine.config.groups) {
            counts[group.id] = this.engine.getGroupQty(group);
        }
        if (currentGroup) {
            counts.this_group = this.engine.getGroupQty(currentGroup);
        }
        return counts;
    }
}
</file>

<file path="src/core/state.js">
/**
 * Game State - Manages current selection and currencies
 */

export class GameState {
    constructor(config) {
        this.config = config;
        this.reset();
    }

    reset() {
        // ID -> Quantity (Integer)
        this.selected = new Map();
        
        // ID -> Rolled Result (Integer) - Stores the result of random rolls so they persist
        this.rollResults = new Map();

        this.currencies = {};
        this.budgets = {};
        this.resetCurrencies();
    }

    resetCurrencies() {
        if (!this.config.points) {
            console.warn('No points defined in config');
            return;
        }

        this.config.points.forEach(p => {
            this.currencies[p.id] = p.start;
        });
    }

    export() {
        return {
            selected: Array.from(this.selected.entries()),
            rollResults: Array.from(this.rollResults.entries()),
            currencies: { ...this.currencies },
            budgets: { ...this.budgets },
            timestamp: new Date().toISOString()
        };
    }

    import(data) {
        if (Array.isArray(data.selected) && typeof data.selected[0] === 'string') {
            this.selected = new Map(data.selected.map(id => [id, 1]));
        } else {
            this.selected = new Map(data.selected || []);
        }

        // Import roll results
        this.rollResults = new Map(data.rollResults || []);
        
        this.currencies = { ...data.currencies };
        this.budgets = { ...data.budgets };
    }
}
</file>

<file path="src/ui/controls.js">
/**
 * Control Panel - Handles UI controls (buttons, settings)
 */

import { CYOAEditor } from './editor.js';

export class ControlPanel {
    constructor(engine, renderer) {
        this.engine = engine;
        this.renderer = renderer;
        this.editor = new CYOAEditor(engine, renderer);

        this.setupControls();
        console.log('üéÆ Controls initialized');
    }

    // ==================== SETUP ====================

    setupControls() {
        // Text toggle
        const textBtn = document.getElementById('text-toggle');
        if (textBtn) {
            textBtn.addEventListener('click', () => this.toggleText());
        }

        // Edit/Debug toggle (Renamed)
        const editBtn = document.getElementById('edit-toggle');
        if (editBtn) {
            editBtn.addEventListener('click', () => this.toggleEditMode());
        }

        // Reset
        const resetBtn = document.getElementById('reset-btn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => this.reset());
        }
    }

    // ==================== ACTIONS ====================

    toggleText() {
        document.body.classList.toggle('text-mode');
        const btn = document.getElementById('text-toggle');
        if (btn) {
            btn.classList.toggle('active');
        }
    }

    toggleEditMode() {
        // Toggle the main edit class
        document.body.classList.toggle('edit-mode-active');
        
        const btn = document.getElementById('edit-toggle');
        if (btn) {
            btn.classList.toggle('active');
        }

        const isActive = document.body.classList.contains('edit-mode-active');
        
        // Enable/disable editor logic
        if (isActive) {
            this.editor.enable();
            // Also enable visual debug borders for items by default
            document.body.classList.add('show-zones'); 
        } else {
            this.editor.disable();
            document.body.classList.remove('show-zones');
            document.body.classList.remove('edit-mode-choice');
            document.body.classList.remove('edit-mode-group');
        }
        
        console.log(isActive ? '‚úèÔ∏è Edit mode ON' : '‚úèÔ∏è Edit mode OFF');
    }

    reset() {
        if (confirm('Reset all selections?')) {
            this.engine.reset();
            console.log('üîÑ Reset complete');
        }
    }
}
</file>

<file path="src/ui/editor.js">
/**
 * CYOA Editor - Visual editing mode
 */

import { CoordHelper } from '../utils/coords.js';
import { RuleBuilder } from './rule-builder.js';
import { AutoDetector } from '../utils/autodetect.js';

export class CYOAEditor {
    constructor(engine, renderer) {
        this.engine = engine;
        this.renderer = renderer;
        this.ruleBuilder = new RuleBuilder(engine);
        this.autoDetector = new AutoDetector(); 
        
        this.selectedItem = null;
        this.selectedGroup = null;
        this.activeTab = 'choice'; 
        
        this.measureContext = document.createElement('canvas').getContext('2d');
        
        this.mirrorDiv = document.createElement('div');
        this.mirrorDiv.style.cssText = 'position:absolute; visibility:hidden; height:auto; overflow:hidden; white-space:pre-wrap; word-wrap:break-word;';
        document.body.appendChild(this.mirrorDiv);

        this.isDragging = false;
        this.isResizing = false;
        this.dragStart = { x: 0, y: 0 };
        this.initialRect = {};
        this.handleSize = 10;
        this.dragContext = null;
        
        this.enabled = false;
        this.triggerLabelCheck = null;

        console.log('‚úèÔ∏è Editor initialized');
    }

    enable() {
        if (this.enabled) return;
        this.enabled = true;
        this.createEditorUI();
        this.attachEventListeners();
        this.switchTab('choice');
        console.log('‚úèÔ∏è Editor enabled');
    }

    disable() {
        if (!this.enabled) return;
        this.enabled = false;
        const sidebar = document.getElementById('editor-sidebar');
        if (sidebar) sidebar.remove();
        this.removeEventListeners();
        document.querySelectorAll('.item-zone, .info-zone').forEach(el => {
            el.classList.remove('editable', 'editor-selected');
        });
        console.log('‚úèÔ∏è Editor disabled');
    }

    createEditorUI() {
        if (document.getElementById('editor-sidebar')) return;
        
        const sidebar = document.createElement('div');
        sidebar.id = 'editor-sidebar';
        sidebar.className = 'editor-sidebar';
        
        sidebar.innerHTML = `
            <div class="editor-tabs">
                <button class="tab-btn" data-tab="choice" onclick="CYOA.editor.switchTab('choice')">Choice</button>
                <button class="tab-btn" data-tab="group" onclick="CYOA.editor.switchTab('group')">Group</button>
                <button class="tab-btn" data-tab="settings" onclick="CYOA.editor.switchTab('settings')">Settings</button>
                <button class="close-tab-btn" onclick="CYOA.controls.toggleEditMode()">‚úï</button>
            </div>
            
            <div class="sidebar-scroll-content">
                
                <!-- TAB 1: CHOICE -->
                <div id="tab-content-choice" class="tab-content" style="display:none;">
                    <div id="choice-empty-state" class="info-text">
                        Select an item on the page to edit.
                    </div>

                    <div id="choice-props" style="display:none;">
                        <div class="editor-section">
                            <div class="row-2">
                                <div class="input-group">
                                    <input type="text" id="edit-id">
                                    <span class="input-label">ID</span>
                                </div>
                                <div class="input-group">
                                    <input type="text" id="edit-parent-group" readonly style="color:#888; cursor:default;">
                                    <span class="input-label">GRP</span>
                                </div>
                            </div>
                            
                            <div class="input-group">
                                <input type="number" id="edit-max_quantity" min="1" placeholder="1">
                                <span class="input-label">Max Qty</span>
                            </div>

                            <div class="input-group">
                                <input type="text" id="edit-title">
                                <span class="input-label">Title</span>
                            </div>

                            <div class="input-group">
                                <input type="text" id="edit-tags" placeholder="magic, fire">
                                <span class="input-label">Tags</span>
                            </div>

                            <div class="input-group">
                                <textarea id="edit-description" rows="5"></textarea>
                                <span class="input-label">Desc</span>
                            </div>
                        </div>

                        <div class="editor-section">
                            <div class="accordion-header" onclick="CYOA.editor.toggleAccordion(this)">
                                Position & Size
                            </div>
                            <div class="accordion-content">
                                <div class="row-4">
                                    <div class="input-group" title="X"><input type="number" id="edit-x"></div>
                                    <div class="input-group" title="Y"><input type="number" id="edit-y"></div>
                                    <div class="input-group" title="Width"><input type="number" id="edit-w"></div>
                                    <div class="input-group" title="Height"><input type="number" id="edit-h"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="rule-builder-container"></div>

                        <div class="editor-section">
                            <div class="accordion-header collapsed" onclick="CYOA.editor.toggleAccordion(this)">
                                üîß Raw JSON
                            </div>
                            <div class="accordion-content collapsed">
                                <textarea id="edit-raw-json" class="code-editor"></textarea>
                            </div>
                        </div>
                        
                        <div class="editor-section" style="margin-top: 10px; border-top: 1px solid #222;">
                            <div class="row-buttons">
                                <button class="action-btn btn-delete" onclick="CYOA.editor.deleteSelectedItem()">üóëÔ∏è Delete</button>
                                <button class="action-btn btn-add" onclick="CYOA.editor.addNewItem()">‚ûï Add New</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- TAB 2: GROUP -->
                <div id="tab-content-group" class="tab-content" style="display:none;">
                    <div id="group-empty-state" class="info-text">
                        Select a group (Info Box) or a choice first.
                    </div>

                    <div id="group-props" style="display:none;">
                         <div class="editor-section">
                            <div class="input-group">
                                <input type="text" id="group-id">
                                <span class="input-label">Group ID</span>
                            </div>
                            <div class="input-group">
                                <input type="text" id="group-title">
                                <span class="input-label">Title</span>
                            </div>
                            <div class="input-group">
                                <textarea id="group-description" rows="7"></textarea>
                                <span class="input-label">Description</span>
                            </div>
                        </div>

                        <div class="editor-section">
                            <div class="accordion-header" onclick="CYOA.editor.toggleAccordion(this)">
                                Position & Size
                            </div>
                            <div class="accordion-content">
                                <div class="row-4">
                                    <div class="input-group" title="X"><input type="number" id="group-x"></div>
                                    <div class="input-group" title="Y"><input type="number" id="group-y"></div>
                                    <div class="input-group" title="Width"><input type="number" id="group-w"></div>
                                    <div class="input-group" title="Height"><input type="number" id="group-h"></div>
                                </div>
                            </div>
                        </div>
                        
                         <div class="editor-section">
                             <div class="accordion-header" onclick="CYOA.editor.toggleAccordion(this)">
                                 üìú Group Rules (JSON)
                             </div>
                             <div class="accordion-content">
                                 <textarea id="group-rules-json" class="code-editor" style="height:150px;"></textarea>
                             </div>
                         </div>

                        <div class="editor-section" style="margin-top: 10px; border-top: 1px solid #222;">
                            <div class="row-buttons">
                                <button class="action-btn btn-delete" onclick="CYOA.editor.deleteSelectedGroup()">üóëÔ∏è Delete Group</button>
                                <button class="action-btn btn-add" onclick="CYOA.editor.addNewGroup()">‚ûï Add Group</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- TAB 3: SETTINGS -->
                <div id="tab-content-settings" class="tab-content" style="display:none;">
                    
                    <!-- SAM3 DETECTOR -->
                    <div class="editor-section">
                        <div class="accordion-header" onclick="CYOA.editor.toggleAccordion(this)">
                            ü§ñ Auto-Detect (SAM3)
                        </div>
                        <div class="accordion-content">
                            
                            <!-- Help Accordion -->
                            <div style="margin-bottom:10px; border:1px solid #333; border-radius:4px;">
                                <div style="padding:5px 10px; background:#222; font-size:0.8rem; cursor:pointer;" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display==='none'?'block':'none'">
                                    ‚ùì How to get HF Token (Free)
                                </div>
                                <div style="display:none; padding:10px; font-size:0.75rem; color:#aaa; background:#1a1a1a;">
                                    1. Register at <a href="https://huggingface.co/join" target="_blank" style="color:#4CAF50;">Hugging Face</a> (Free, No Credit Card).<br>
                                    2. Verify email.<br>
                                    3. Go to <a href="https://huggingface.co/settings/tokens" target="_blank" style="color:#4CAF50;">Settings > Tokens</a>.<br>
                                    4. Create new token (Type: <b>Read</b>).<br>
                                    5. Copy token (starts with hf_...).<br><br>
                                    <span style="color:#ffd700;">‚ö†Ô∏è Note: Free tier can be slow. Daily limit: ~15-20 images.</span>
                                </div>
                            </div>

                            <div class="input-group">
                                <input type="password" id="sam-token" placeholder="hf_...">
                                <span class="input-label">Hugging Face Token</span>
                            </div>

                            <div class="editor-section" style="border:none; padding:0;">
                                <label style="font-size:0.8rem; color:#888;">Working Image (Resets current items!)</label>
                                <input type="file" id="sam-image-upload" accept="image/*" style="width:100%; margin-top:5px; font-size:0.8rem;">
                            </div>

                            <div class="input-group" style="margin-top:10px;">
                                <input type="text" id="sam-prompt" value="content block, game card, description panel">
                                <span class="input-label">Search Prompt</span>
                            </div>

                            <div style="margin-top:10px;">
                                <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#888;">
                                    <span>Shave (Tightness)</span>
                                    <span id="shave-val">2.0%</span>
                                </div>
                                <input type="range" id="sam-shave" min="0.005" max="0.05" step="0.005" value="0.02" style="width:100%;" 
                                       oninput="document.getElementById('shave-val').textContent = (this.value*100).toFixed(1)+'%'">
                            </div>

                            <!-- Debug Index Input -->
                            <div class="input-group" style="margin-top:10px;">
                                <input type="number" id="sam-debug-index" placeholder="None">
                                <span class="input-label">Debug Item Index (Optional)</span>
                            </div>

                            <button id="btn-run-sam" class="full-width-btn primary-btn" style="margin-top:15px; background: linear-gradient(45deg, #4b6cb7, #182848);">
                                üöÄ Run Auto-Detect
                            </button>
                            
                            <div id="sam-status" style="margin-top:10px; font-size:0.75rem; color:#ffd700; min-height:1.2em;"></div>

                            <!-- DEBUG GALLERY -->
                            <div class="editor-section" style="margin-top:15px; border:1px solid #333; padding:0;">
                                <div class="accordion-header collapsed" onclick="CYOA.editor.toggleAccordion(this)" style="padding:5px 10px; font-size:0.8rem;">
                                    üêû Debug Gallery
                                </div>
                                <div class="accordion-content collapsed" id="sam-debug-gallery" style="background:#000; padding:10px;">
                                    <div style="font-size:0.7rem; color:#666;">Images will appear here...</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- File Operations -->
                    <div class="editor-section">
                        <div class="accordion-header">File Operations</div>
                        <div class="accordion-content" style="display:block">
                            <button class="full-width-btn primary-btn" onclick="CYOA.editor.exportConfig()">
                                üíæ Save JSON
                            </button>
                            <button class="full-width-btn" style="margin-top:10px; background:#444;" onclick="CYOA.editor.exportZip()">
                                üì¶ Save All (Zip)
                            </button>
                        </div>
                    </div>
                </div>

            </div>
        `;
        
        document.body.appendChild(sidebar);
        this.ruleBuilder.renderUI(document.getElementById('rule-builder-container'));
        
        this.setupChoiceListeners();
        this.setupGroupListeners();
        this.setupJsonListeners();
        this.setupLabelAutoHiding();
        this.setupSamListeners();
    }

    switchTab(tabName) {
        this.activeTab = tabName;
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabName);
        });
        document.querySelectorAll('.tab-content').forEach(content => {
            content.style.display = 'none';
        });
        document.getElementById(`tab-content-${tabName}`).style.display = 'block';

        document.body.classList.remove('edit-mode-choice', 'edit-mode-group');

        if (tabName === 'choice') {
            document.body.classList.add('edit-mode-choice');
            if (this.selectedItem) {
                this.updateChoiceInputs();
                document.getElementById('choice-empty-state').style.display = 'none';
                document.getElementById('choice-props').style.display = 'block';
            }
        } else if (tabName === 'group') {
            document.body.classList.add('edit-mode-group');
            if (this.selectedItem) {
                const group = this.engine.findGroupForItem(this.selectedItem.id);
                if (group) this.selectGroup(group);
            }
            if (this.selectedGroup) {
                document.getElementById('group-empty-state').style.display = 'none';
                document.getElementById('group-props').style.display = 'block';
            }
        }
    }

    toggleAccordion(header) {
        header.classList.toggle('collapsed');
        const content = header.nextElementSibling;
        content.classList.toggle('collapsed');
    }

    setupLabelAutoHiding() {
        const checkCollision = (input) => {
            const label = input.nextElementSibling;
            if (!label || !label.classList.contains('input-label')) return;
            const inputStyle = window.getComputedStyle(input);

            if (input.tagName === 'TEXTAREA') {
                this.mirrorDiv.style.font = inputStyle.font;
                this.mirrorDiv.style.width = inputStyle.width;
                this.mirrorDiv.style.padding = inputStyle.padding;
                this.mirrorDiv.textContent = input.value + '|';
                if (input.scrollHeight > input.clientHeight) {
                    label.classList.add('label-hidden');
                } else {
                     label.classList.remove('label-hidden');
                }
                return;
            }
            
            this.measureContext.font = inputStyle.font;
            const textWidth = this.measureContext.measureText(input.value).width;
            if ((textWidth + 10) > (input.clientWidth - label.offsetWidth - 10)) {
                label.classList.add('label-hidden');
            } else {
                label.classList.remove('label-hidden');
            }
        };

        const attach = () => {
             const inputs = document.querySelectorAll('#editor-sidebar input[type="text"], #editor-sidebar input[type="number"], #editor-sidebar input[type="password"], #editor-sidebar textarea:not(.code-editor)');
             inputs.forEach(input => {
                input.removeEventListener('input', input._labelHandler);
                input._labelHandler = () => checkCollision(input);
                input.addEventListener('input', input._labelHandler);
                checkCollision(input);
             });
        };
        this.triggerLabelCheck = attach;
        setTimeout(attach, 500); 
    }

    setupSamListeners() {
        const fileInput = document.getElementById('sam-image-upload');
        if (fileInput) {
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const dataUrl = evt.target.result;
                        this.engine.config.meta.pages[0] = dataUrl;
                        this.engine.config.groups = [];
                        this.engine.config.points = [{id:"points", name:"Points", start:0}];
                        this.engine.reset();
                        this.renderer.renderAll().then(() => {
                             const img = document.querySelector('#page-0 .page-image');
                             if(img) {
                                 this.renderer.pageDimensions[0] = { w: img.naturalWidth, h: img.naturalHeight };
                             }
                        });
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        const runBtn = document.getElementById('btn-run-sam');
        if (runBtn) {
            runBtn.addEventListener('click', () => this.runSamDetection());
        }
    }

    async runSamDetection() {
        const fileInput = document.getElementById('sam-image-upload');
        const tokenInput = document.getElementById('sam-token');
        const promptInput = document.getElementById('sam-prompt');
        const shaveInput = document.getElementById('sam-shave');
        const debugIdxInput = document.getElementById('sam-debug-index');
        const statusEl = document.getElementById('sam-status');
        const galleryEl = document.getElementById('sam-debug-gallery');

        if (!fileInput.files[0]) { alert("Please upload an image first!"); return; }
        if (!tokenInput.value) { alert("Please enter your Hugging Face Token!"); return; }

        const btn = document.getElementById('btn-run-sam');
        btn.disabled = true;
        btn.style.opacity = 0.5;

        galleryEl.innerHTML = '';
        
        let debugIdx = -1;
        if (debugIdxInput.value) {
            debugIdx = parseInt(debugIdxInput.value) - 1; 
        }

        this.autoDetector.statusCallback = (msg) => { statusEl.textContent = msg; };

        this.autoDetector.debugCallback = (title, dataUrl) => {
            const wrapper = document.createElement('div');
            wrapper.style.marginBottom = "15px";
            const label = document.createElement('div');
            label.textContent = title;
            label.style.color = "#4CAF50";
            label.style.fontSize = "0.75rem";
            label.style.marginBottom = "5px";
            const img = document.createElement('img');
            img.src = dataUrl;
            img.style.maxWidth = "100%";
            img.style.border = "1px solid #444";
            img.style.cursor = "pointer";
            img.onclick = () => {
                const w = window.open("");
                w.document.write(`<img src="${dataUrl}" style="border:1px solid red;">`);
            };
            wrapper.appendChild(label);
            wrapper.appendChild(img);
            galleryEl.appendChild(wrapper);
            const accHeader = galleryEl.previousElementSibling;
            if (accHeader && accHeader.classList.contains('collapsed')) CYOA.editor.toggleAccordion(accHeader);
        };

        const detectedItems = await this.autoDetector.processImage(
            fileInput.files[0],
            promptInput.value,
            parseFloat(shaveInput.value),
            tokenInput.value,
            debugIdx
        );

        if (detectedItems.length > 0) {
            let group = this.engine.config.groups[0];
            if (!group) {
                group = {
                    id: "generated_group",
                    title: "Detected Items",
                    page: 0,
                    coords: { x: 50, y: 50, w: 500, h: 200 },
                    items: []
                };
                this.engine.config.groups.push(group);
            }

            group.items = [...group.items, ...detectedItems];
            
            this.engine.recalculate();
            this.renderer.renderButtons();
            
            statusEl.textContent = `Done! Added ${detectedItems.length} items.`;
            this.switchTab('choice');
        } else {
             statusEl.textContent = "No items found.";
        }

        btn.disabled = false;
        btn.style.opacity = 1;
    }

    attachEventListeners() {
        document.addEventListener('mousedown', this.handleMouseDown.bind(this));
        document.addEventListener('mousemove', this.handleMouseMove.bind(this));
        document.addEventListener('mouseup', this.handleMouseUp.bind(this));
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
    }
    removeEventListeners() {}

    handleMouseDown(e) {
        if (!this.enabled) return;
        if (e.target.closest('#editor-sidebar')) return;
        let target = null;
        let objectToEdit = null;
        if (this.activeTab === 'group') {
            target = e.target.closest('.info-zone');
            if (target) {
                const gid = target.id.replace('group-', '');
                const group = this.engine.config.groups.find(g => g.id === gid);
                if (group) { this.selectGroup(group); objectToEdit = group; }
            }
        } else {
            target = e.target.closest('.item-zone');
            if (target) {
                const itemId = target.dataset.itemId;
                const item = this.engine.findItem(itemId);
                if (item) { this.selectChoice(item, target); objectToEdit = item; this.selectedGroup = this.engine.findGroupForItem(item.id); }
            } else if(this.activeTab === 'choice') { this.deselectChoice(); }
        }
        if (objectToEdit && target) {
            target.classList.add('dragging');
            const rect = target.getBoundingClientRect();
            if (e.clientX >= rect.right - this.handleSize && e.clientY >= rect.bottom - this.handleSize) { this.isResizing = true; } 
            else { this.isDragging = true; }
            this.dragStart = { x: e.clientX, y: e.clientY };
            if (!objectToEdit.coords) objectToEdit.coords = {x:0,y:0,w:100,h:100};
            this.initialRect = { ...objectToEdit.coords };
            const group = (objectToEdit.items) ? objectToEdit : this.engine.findGroupForItem(objectToEdit.id);
            const pageIndex = group?.page || 0;
            const dim = this.renderer.pageDimensions[pageIndex];
            const container = document.querySelector(`#page-${pageIndex}`);
            if (dim && container) {
                const containerRect = container.getBoundingClientRect();
                this.dragContext = { scaleX: dim.w / containerRect.width, scaleY: dim.h / containerRect.height, dim: dim, targetObj: objectToEdit };
            }
            e.preventDefault();
        }
    }

    handleMouseMove(e) {
        if (!this.enabled || !this.dragContext) return;
        if (!this.isDragging && !this.isResizing) return;
        const dx = e.clientX - this.dragStart.x;
        const dy = e.clientY - this.dragStart.y;
        const { scaleX, scaleY, dim, targetObj } = this.dragContext;
        if (this.isDragging) {
            targetObj.coords.x = Math.round(this.initialRect.x + dx * scaleX);
            targetObj.coords.y = Math.round(this.initialRect.y + dy * scaleY);
        } else if (this.isResizing) {
            targetObj.coords.w = Math.max(20, Math.round(this.initialRect.w + dx * scaleX));
            targetObj.coords.h = Math.max(20, Math.round(this.initialRect.h + dy * scaleY));
        }
        let domId = targetObj.items ? `group-${targetObj.id}` : `btn-${targetObj.id}`;
        const element = document.getElementById(domId);
        if (element) { const style = CoordHelper.toPercent(targetObj.coords, dim); Object.assign(element.style, style); }
        if (this.activeTab === 'group') this.updateGroupInputs(); else this.updateChoiceInputs();
    }

    handleMouseUp() {
        document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
        this.isDragging = false; this.isResizing = false; this.dragContext = null;
    }

    handleKeyDown(e) {
        if (!this.enabled) return;
        if (e.key === 'Delete') {
             const tag = document.activeElement.tagName;
             if (tag !== 'INPUT' && tag !== 'TEXTAREA') {
                 if (this.activeTab === 'choice') this.deleteSelectedItem();
             }
        }
    }

    selectChoice(item, element) {
        this.selectedItem = item;
        document.querySelectorAll('.editor-selected').forEach(el => el.classList.remove('editor-selected'));
        if(element) element.classList.add('editor-selected');
        document.getElementById('choice-empty-state').style.display = 'none';
        document.getElementById('choice-props').style.display = 'block';
        this.updateChoiceInputs();
        this.ruleBuilder.loadItem(item, this.engine.findGroupForItem(item.id));
    }

    deselectChoice() {
        this.selectedItem = null;
        document.querySelectorAll('.item-zone.editor-selected').forEach(el => el.classList.remove('editor-selected'));
        document.getElementById('choice-props').style.display = 'none';
        document.getElementById('choice-empty-state').style.display = 'block';
    }

    selectGroup(group) {
        this.selectedGroup = group;
        document.querySelectorAll('.info-zone.editor-selected').forEach(el => el.classList.remove('editor-selected'));
        const el = document.getElementById(`group-${group.id}`);
        if(el) el.classList.add('editor-selected');
        document.getElementById('group-empty-state').style.display = 'none';
        document.getElementById('group-props').style.display = 'block';
        this.updateGroupInputs();
    }

    updateChoiceInputs() {
        if (!this.selectedItem) return;
        const item = this.selectedItem;
        const group = this.engine.findGroupForItem(item.id);
        document.getElementById('edit-id').value = item.id || '';
        document.getElementById('edit-parent-group').value = group ? group.id : '?';
        document.getElementById('edit-max_quantity').value = item.max_quantity || 1;
        document.getElementById('edit-title').value = item.title || '';
        document.getElementById('edit-description').value = item.description || '';
        document.getElementById('edit-tags').value = (item.tags || []).join(', ');
        ['x','y','w','h'].forEach(k => { document.getElementById(`edit-${k}`).value = Math.round(item.coords?.[k] || 0); });
        this.updateCodePreview();
        if (this.triggerLabelCheck) this.triggerLabelCheck();
    }

    updateGroupInputs() {
        if (!this.selectedGroup) return;
        const g = this.selectedGroup;
        document.getElementById('group-id').value = g.id || '';
        document.getElementById('group-title').value = g.title || '';
        document.getElementById('group-description').value = g.description || '';
        ['x','y','w','h'].forEach(k => { document.getElementById(`group-${k}`).value = Math.round(g.coords?.[k] || 0); });
        this.updateCodePreview();
        if (this.triggerLabelCheck) this.triggerLabelCheck();
    }

    updateCodePreview() {
        if (this.selectedItem) {
            const el = document.getElementById('edit-raw-json');
            if (el && document.activeElement !== el) el.value = JSON.stringify(this.selectedItem, null, 2);
        }
        if (this.selectedGroup) {
            const rulesEl = document.getElementById('group-rules-json');
            if (rulesEl && document.activeElement !== rulesEl) rulesEl.value = JSON.stringify(this.selectedGroup.rules || {}, null, 2);
        }
    }

    setupChoiceListeners() {
        const update = (key, val, isNum) => {
            if (!this.selectedItem) return;
            if (isNum) val = parseInt(val) || 0;
            if (['x','y','w','h'].includes(key)) { if (!this.selectedItem.coords) this.selectedItem.coords = {}; this.selectedItem.coords[key] = val; } 
            else if (key === 'tags') { this.selectedItem.tags = val.split(',').map(t => t.trim()).filter(t => t); } 
            else { this.selectedItem[key] = val; }
            if (key === 'max_quantity') {
                 if (val <= 1) delete this.selectedItem.max_quantity;
                 this.renderer.renderButtons();
                 setTimeout(() => { const el = document.getElementById(`btn-${this.selectedItem.id}`); if (el) el.classList.add('editor-selected'); }, 0);
            } else { this.renderer.renderButtons(); }
            this.updateCodePreview();
        };
        const inputs = ['edit-id', 'edit-title', 'edit-description', 'edit-tags', 'edit-x', 'edit-y', 'edit-w', 'edit-h', 'edit-max_quantity'];
        inputs.forEach(id => {
            const el = document.getElementById(id); if (!el) return;
            const key = id.split('-').pop(); const realKey = (id === 'edit-description') ? 'description' : key; const isNum = ['x','y','w','h', 'max_quantity'].includes(key); 
            el.addEventListener('input', (e) => update(realKey, e.target.value, isNum));
        });
    }

    setupGroupListeners() {
        const update = (key, val, isNum) => {
            if (!this.selectedGroup) return;
            if (isNum) val = parseInt(val) || 0;
            if (['x','y','w','h'].includes(key)) { if (!this.selectedGroup.coords) this.selectedGroup.coords = {}; this.selectedGroup.coords[key] = val; } 
            else { this.selectedGroup[key] = val; }
            this.renderer.renderButtons();
            this.updateCodePreview();
        };
        const inputs = ['group-id', 'group-title', 'group-description', 'group-x', 'group-y', 'group-w', 'group-h'];
        inputs.forEach(id => {
            const el = document.getElementById(id); if (!el) return;
            const key = id.split('-').pop(); const realKey = (id === 'group-description') ? 'description' : key; const isNum = ['x','y','w','h'].includes(key);
            el.addEventListener('input', (e) => update(realKey, e.target.value, isNum));
        });
    }

    setupJsonListeners() {
        const choiceJson = document.getElementById('edit-raw-json');
        if (choiceJson) {
            choiceJson.addEventListener('change', (e) => {
                try { const data = JSON.parse(e.target.value); if (this.selectedItem) { Object.assign(this.selectedItem, data); this.renderer.renderButtons(); this.updateChoiceInputs(); this.ruleBuilder.loadItem(this.selectedItem, this.selectedGroup); } } catch(err) { console.error("JSON Error", err); }
            });
        }
        const rulesJson = document.getElementById('group-rules-json');
        if (rulesJson) {
            rulesJson.addEventListener('change', (e) => {
                try { const data = JSON.parse(e.target.value); if (this.selectedGroup) { this.selectedGroup.rules = data; this.renderer.renderButtons(); this.engine.recalculate(); } } catch(err) { console.error("Rules JSON Error", err); }
            });
        }
    }

    deleteSelectedItem() {
        if (!this.selectedItem) return; if (!confirm('Delete item?')) return;
        const group = this.engine.findGroupForItem(this.selectedItem.id);
        if (group) { const idx = group.items.indexOf(this.selectedItem); if (idx > -1) group.items.splice(idx, 1); }
        this.deselectChoice(); this.renderer.renderButtons();
    }
    addNewItem() {
        let group = this.selectedGroup || this.engine.config.groups[0]; if (!group) return;
        const newItem = { id: `item_${Date.now()}`, title: 'New Item', description: '', coords: { x: 50, y: 50, w: 200, h: 100 }, cost: [] };
        group.items.push(newItem); this.renderer.renderButtons();
        setTimeout(() => { const el = document.getElementById(`btn-${newItem.id}`); if (el) this.selectChoice(newItem, el); }, 50);
    }
    addNewGroup() {
        const newGroup = { id: `group_${Date.now()}`, title: 'New Group', description: '', page: 0, coords: { x: 50, y: 50, w: 300, h: 200 }, items: [] };
        this.engine.config.groups.push(newGroup); this.renderer.renderButtons();
        setTimeout(() => { const el = document.getElementById(`group-${newGroup.id}`); if (el) this.selectGroup(newGroup); }, 50);
    }
    deleteSelectedGroup() {
        if (!this.selectedGroup) return;
        if (this.selectedGroup.items && this.selectedGroup.items.length > 0) { if (!confirm(`Group has ${this.selectedGroup.items.length} items. Delete group and ALL items?`)) return; } 
        else { if (!confirm('Delete this group?')) return; }
        const idx = this.engine.config.groups.indexOf(this.selectedGroup); if (idx > -1) { this.engine.config.groups.splice(idx, 1); }
        this.selectedGroup = null; document.querySelectorAll('.info-zone.editor-selected').forEach(el => el.classList.remove('editor-selected'));
        document.getElementById('group-props').style.display = 'none'; document.getElementById('group-empty-state').style.display = 'block';
        this.renderer.renderButtons();
    }

    exportConfig() {
        const config = this.engine.config;
        const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `${config.meta?.title || 'cyoa'}_edited.json`; a.click(); URL.revokeObjectURL(url);
    }

    async exportZip() {
        let JSZip;
        try { const module = await import('https://cdn.jsdelivr.net/npm/jszip/+esm'); JSZip = module.default; } 
        catch (e) { alert("Could not load JSZip library."); return; }

        const zip = new JSZip();
        
        const configToSave = JSON.parse(JSON.stringify(this.engine.config));
        configToSave.meta.pages[0] = "image.png"; 
        
        zip.file("config.json", JSON.stringify(configToSave, null, 2));

        const dataUrl = this.engine.config.meta.pages[0];
        if (dataUrl && dataUrl.startsWith('data:image')) {
            const resp = await fetch(dataUrl);
            const blob = await resp.blob();
            zip.file("image.png", blob);
        } else {
            try {
                const resp = await fetch(dataUrl);
                const blob = await resp.blob();
                zip.file("image.png", blob);
            } catch(e) {
                console.warn("Could not zip image:", e);
            }
        }

        const content = await zip.generateAsync({type:"blob"});
        const url = URL.createObjectURL(content);
        const a = document.createElement('a'); a.href = url; a.download = "project.zip"; a.click(); URL.revokeObjectURL(url);
    }
}
</file>

<file path="src/ui/renderer.js">
/**
 * UI Renderer - Handles all visual rendering
 */

import { CoordHelper } from '../utils/coords.js';
import { TooltipManager } from './tooltip.js';

export class UIRenderer {
    constructor(engine) {
        this.engine = engine;
        this.pageDimensions = [];
        this.tooltip = new TooltipManager(engine);

        // Listen to engine events
        this.engine.on('selection', () => this.updateUI());
        this.engine.on('recalculate', () => this.updateUI());
        this.engine.on('reset', () => this.updateUI());

        console.log('üé® Renderer initialized');
    }

    // ==================== MAIN RENDER ====================

    async renderAll() {
        await this.renderPages();
        this.renderButtons();
        this.renderPointsBar();
        console.log('‚úÖ All elements rendered');
    }

    // ==================== PAGES ====================

    async renderPages() {
        const wrapper = document.getElementById('game-wrapper');
        wrapper.innerHTML = '';
        this.pageDimensions = [];

        const pages = this.engine.config.meta?.pages || [];
        
        if (pages.length === 0) {
            console.warn('No pages defined in config');
            return;
        }

        const loadPromises = pages.map((src, index) => {
            return new Promise((resolve) => {
                const container = document.createElement('div');
                container.className = 'page-container';
                container.id = `page-${index}`;

                const img = document.createElement('img');
                img.className = 'page-image';
                img.src = src;
                img.alt = `Page ${index + 1}`;

                const layer = document.createElement('div');
                layer.className = 'page-layer';
                layer.id = `layer-${index}`;

                container.appendChild(img);
                container.appendChild(layer);
                wrapper.appendChild(container);

                img.onload = () => {
                    this.pageDimensions[index] = {
                        w: img.naturalWidth,
                        h: img.naturalHeight
                    };
                    resolve();
                };

                img.onerror = () => {
                    this.pageDimensions[index] = { w: 1920, h: 1080 };
                    resolve();
                };
            });
        });

        await Promise.all(loadPromises);
    }

    // ==================== BUTTONS ====================

    renderButtons() { 
        const pages = this.engine.config.meta?.pages || [];
        pages.forEach((_, index) => {
            const layer = document.getElementById(`layer-${index}`);
            if (layer) layer.innerHTML = '';  
        });

        const groups = this.engine.config.groups || [];

        groups.forEach(group => {
            const pageIndex = group.page !== undefined ? group.page : 0;
            const layer = document.getElementById(`layer-${pageIndex}`);
            
            if (!layer || !this.pageDimensions[pageIndex]) return;

            // Budget badge
            if (group.rules?.budget && group.coords) {
                this.renderBudgetBadge(group, layer, this.pageDimensions[pageIndex]);
            }

            // Group info zone
            if (group.coords) {
                this.renderGroupZone(group, layer, this.pageDimensions[pageIndex]);
            }

            // Items
            if (group.items) {
                group.items.forEach(item => {
                    if (item.coords) {
                        this.renderItemButton(item, group, layer, this.pageDimensions[pageIndex]);
                    }
                });
            }
        });
        
        this.updateButtons();
    }

    renderBudgetBadge(group, layer, dim) {
        const badge = document.createElement('div');
        badge.className = 'group-budget-badge';
        badge.id = `budget-${group.id}`;

        const style = CoordHelper.toPercent(group.coords, dim);
        const leftVal = parseFloat(style.left);
        const widthVal = parseFloat(style.width);
        const topVal = parseFloat(style.top);

        badge.style.left = (leftVal + widthVal / 2) + '%';
        badge.style.top = topVal + '%';

        layer.appendChild(badge);
        this.updateBudgetBadge(group);
    }

    renderGroupZone(group, layer, dim) {
        const zone = document.createElement('div');
        zone.className = 'click-zone info-zone';
        zone.id = `group-${group.id}`;

        Object.assign(zone.style, CoordHelper.toPercent(group.coords, dim));

        if (group.title || group.description) {
            zone.appendChild(this.createTextLayer(
                group.title || '',
                group.description || ''
            ));
        }

        layer.appendChild(zone);
    }

    renderItemButton(item, group, layer, dim) {
        const button = document.createElement('div');
        button.className = 'click-zone item-zone';
        button.id = `btn-${item.id}`;
        button.dataset.itemId = item.id;
        button.dataset.groupId = group.id;

        Object.assign(button.style, CoordHelper.toPercent(item.coords, dim));

        // Text layer
        if (item.title || item.description) {
            button.appendChild(this.createTextLayer(
                item.title || '',
                item.description || ''
            ));
        }

        const maxQty = item.max_quantity || 1;

        if (maxQty > 1) {
            button.classList.add('multi-select');
            const controls = document.createElement('div');
            controls.className = 'split-controls';
            
            const minusBtn = document.createElement('div');
            minusBtn.className = 'split-btn minus';
            minusBtn.onclick = (e) => {
                e.stopPropagation(); 
                this.engine.deselect(item.id);
            };

            const plusBtn = document.createElement('div');
            plusBtn.className = 'split-btn plus';
            plusBtn.onclick = (e) => {
                e.stopPropagation();
                this.engine.select(item.id);
            };

            controls.appendChild(minusBtn);
            controls.appendChild(plusBtn);
            button.appendChild(controls);

            const badge = document.createElement('div');
            badge.className = 'qty-badge';
            badge.style.display = 'none'; 
            button.appendChild(badge);

        } else {
            button.onclick = () => {
                this.engine.toggle(item.id);
            };
        }

        this.tooltip.attach(button, item, group);

        layer.appendChild(button);
    }

    createTextLayer(title, description) {
        const div = document.createElement('div');
        div.className = 'text-content';
        const cleanDesc = description ? description.replace(/\n/g, '<br>') : '';
        div.innerHTML = `
            ${title ? `<strong>${title}</strong>` : ''}
            ${cleanDesc ? `<span>${cleanDesc}</span>` : ''}
        `;
        return div;
    }

    renderPointsBar() {
        const bar = document.getElementById('points-bar');
        bar.innerHTML = '';
        const points = this.engine.config.points || [];

        points.forEach(p => {
            const div = document.createElement('div');
            div.className = 'currency';
            div.id = `curr-${p.id}`;
            div.innerHTML = `
                ${p.name}: 
                <span>${this.engine.state.currencies[p.id] || p.start}</span>
            `;
            bar.appendChild(div);
        });
    }

    // ==================== UPDATE UI ====================

    updateUI() {
        this.updateButtons();
        this.updatePointsBar();
        this.updateBudgets();
    }

    updateButtons() {
        document.querySelectorAll('.item-zone').forEach(el => {
            const itemId = el.dataset.itemId;
            const groupId = el.dataset.groupId;

            const item = this.engine.findItem(itemId);
            const group = this.engine.findGroupForItem(itemId);

            if (!item || !group) return;

            const qty = this.engine.state.selected.get(itemId) || 0;
            const isSelected = qty > 0;
            const canSelect = this.engine.canSelect(item, group);
            const maxQty = item.max_quantity || 1;

            el.classList.toggle('selected', isSelected);

            if (maxQty > 1) {
                el.classList.toggle('maxed', qty >= maxQty);
                const badge = el.querySelector('.qty-badge');
                if (badge) {
                    badge.textContent = qty;
                    badge.style.display = isSelected ? 'flex' : 'none';
                }
            } else {
                el.classList.toggle('disabled', !canSelect && !isSelected);
            }

            // === ROULETTE LOGIC ===
            const hasDiceEffect = item.effects && item.effects.some(e => e.type === 'roll_dice');
            
            if (hasDiceEffect) {
                const rolledValue = this.engine.state.rollResults.get(itemId);
                const currentBadge = el.querySelector('.roll-result-badge');
                const isSpinning = el.classList.contains('spinning-active');

                if (isSelected && rolledValue !== undefined) {
                    // Only animate if it's the FIRST time (no badge, no spin flag, and we haven't marked it done)
                    if (!el.dataset.hasAnimated && !isSpinning && !currentBadge) {
                        this.playRouletteAnimation(el, rolledValue, item);
                    } else if (el.dataset.hasAnimated && !currentBadge && !isSpinning) {
                        // Restore badge instantly if animation already happened in history
                        this.showPermanentBadge(el, rolledValue, true); // true = instant
                    }
                } else {
                    // Deselected: cleanup
                    const mask = el.querySelector('.roulette-mask');
                    if (mask) mask.remove();
                    if (currentBadge) currentBadge.remove();
                    el.classList.remove('spinning-active');
                    delete el.dataset.hasAnimated;
                }
            }
        });
    }

playRouletteAnimation(container, targetNumber, item) {
        if (container.classList.contains('spinning-active')) return;
        container.classList.add('spinning-active');

        // 1. –°–æ–∑–¥–∞–Ω–∏–µ DOM
        const mask = document.createElement('div');
        mask.className = 'roulette-mask';
        const strip = document.createElement('div');
        strip.className = 'roulette-strip';
        
        // 2. –†–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–æ–≤
        const containerHeight = container.offsetHeight;
        // –í—ã—Å–æ—Ç–∞ —Ü–∏—Ñ—Ä—ã = 65% –æ—Ç –∫–∞—Ä—Ç–æ—á–∫–∏. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–∏–¥–µ—Ç—å –∫—É—Å–æ—á–∫–∏ —Å–æ—Å–µ–¥–µ–π.
        const itemHeight = Math.floor(containerHeight * 0.65); 
        // –°–º–µ—â–µ–Ω–∏–µ, —á—Ç–æ–±—ã —Ü–∏—Ñ—Ä–∞ –≤—Å—Ç–∞–ª–∞ —Ä–æ–≤–Ω–æ –ø–æ —Ü–µ–Ω—Ç—Ä—É –º–∞—Å–∫–∏
        const maskOffset = (containerHeight - itemHeight) / 2;

        // 3. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–∏—Å–µ–ª
        const diceEffect = item.effects.find(e => e.type === 'roll_dice');
        const min = parseInt(diceEffect?.min) || 1;
        const max = parseInt(diceEffect?.max) || 20;

        const totalItems = 30 + Math.floor(Math.random() * 15); // –ù–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è –ª–µ–Ω—Ç–∞
        const numbers = [];
        for (let i = 0; i < totalItems; i++) {
            numbers.push(Math.floor(Math.random() * (max - min + 1)) + min);
        }
        
        // –¶–µ–ª–µ–≤–∞—è —Ü–∏—Ñ—Ä–∞ –≤ –∫–æ–Ω—Ü–µ
        const targetIndex = totalItems - 3; // –û—Å—Ç–∞–≤–ª—è–µ–º 2 —Ü–∏—Ñ—Ä—ã "–∑–∞–ø–∞—Å–∞" —Å–Ω–∏–∑—É
        numbers[targetIndex] = targetNumber;

        strip.innerHTML = numbers.map(n => 
            `<div class="roulette-item" style="height:${itemHeight}px; line-height:${itemHeight}px;">${n}</div>`
        ).join('');
        
        mask.appendChild(strip);
        container.appendChild(mask);

        // 4. –ë–ò–ë–õ–ò–û–¢–ï–ö–ê –ü–†–û–§–ò–õ–ï–ô (–ë–ï–ó –û–¢–°–ö–û–ö–û–í –ù–ê–ó–ê–î)
        // –í—Å–µ bezier <= 1.0. –ù–∏–∫–∞–∫–∏—Ö –≤–æ–∑–≤—Ä–∞—Ç–æ–≤.
        const spinProfiles = [
            // Standard: –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–µ –∑–∞–º–µ–¥–ª–µ–Ω–∏–µ (Ease Out)
            { name: 'standard', duration: 2000, bezier: 'cubic-bezier(0.1, 0.7, 0.1, 1)', type: 'direct' },
            
            // Hard Slam: –û—á–µ–Ω—å —Ä–µ–∑–∫–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞, –∫–∞–∫ —É–¥–∞—Ä –º–æ–ª–æ—Ç–∫–æ–º
            { name: 'slam', duration: 1500, bezier: 'cubic-bezier(0.5, 0.0, 0.1, 1)', type: 'direct' },
            
            // Heavy: –ú–µ–¥–ª–µ–Ω–Ω–æ–µ, —Ç—è–∂–µ–ª–æ–µ —Ç–æ—Ä–º–æ–∂–µ–Ω–∏–µ
            { name: 'heavy', duration: 2500, bezier: 'cubic-bezier(0, 0.95, 0.2, 1)', type: 'direct' },

            // Tease Top: –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è "–Ω–∞–¥" —Ü–∏—Ñ—Ä–æ–π, –ø–æ—Ç–æ–º –ø–∞–¥–∞–µ—Ç –≤–Ω–∏–∑
            // –ò–º–∏—Ç–∏—Ä—É–µ—Ç –∑–∞—Å—Ç—Ä–µ–≤–∞–Ω–∏–µ —à–µ—Å—Ç–µ—Ä–µ–Ω–∫–∏
            { name: 'tease_top', duration: 2000, bezier: 'cubic-bezier(0.1, 1, 0.8, 1)', type: 'nudge', offsetPercent: 0.45 },
            
            // Tease Tiny: –ü–æ—á—Ç–∏ –¥–æ–∫—Ä—É—Ç–∏–ª, –º–∞–ª–µ–Ω—å–∫–∞—è –ø–∞—É–∑–∞, —â–µ–ª—á–æ–∫
            { name: 'tease_tiny', duration: 2200, bezier: 'cubic-bezier(0.1, 1, 0.6, 1)', type: 'nudge', offsetPercent: 0.2 },

            // Slow Grind: –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ –∑–∞–º–µ–¥–ª–µ–Ω–∏–µ (—Å–∫—É—á–Ω–æ, –Ω–æ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ)
            { name: 'grind', duration: 2800, bezier: 'cubic-bezier(0.25, 1, 0.5, 1)', type: 'direct' }
        ];

        const profile = spinProfiles[Math.floor(Math.random() * spinProfiles.length)];
        console.log(`üé∞ Spin: ${profile.name}`);

        // 5. –õ–æ–≥–∏–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        // –ë–∞–∑–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è: —Å–¥–≤–∏–≥–∞–µ–º –ª–µ–Ω—Ç—É –≤–≤–µ—Ä—Ö, —á—Ç–æ–±—ã targetIndex –æ–∫–∞–∑–∞–ª—Å—è –≤ —Ü–µ–Ω—Ç—Ä–µ
        const baseTargetY = -1 * (targetIndex * itemHeight) + maskOffset;
        
        let initialY = baseTargetY;
        
        // –ï—Å–ª–∏ —ç—Ç–æ "Nudge" (—Ç–æ–ª—á–æ–∫), –º—ã —Å–Ω–∞—á–∞–ª–∞ –µ–¥–µ–º –Ω–µ –¥–æ –∫–æ–Ω—Ü–∞
        if (profile.type === 'nudge') {
            // –°–¥–≤–∏–≥–∞–µ–º "–≤–≤–µ—Ä—Ö" (–º–µ–Ω—å—à–µ Y), –∑–Ω–∞—á–∏—Ç –º—ã —É–≤–∏–¥–∏–º —Ç–æ, —á—Ç–æ –ù–ê–î —Ü–∏—Ñ—Ä–æ–π (–ø—Ä–µ–¥—ã–¥—É—â—É—é)
            // –ò–ª–∏ —Å–¥–≤–∏–≥–∞–µ–º "–≤–Ω–∏–∑" (–±–æ–ª—å—à–µ Y), –∑–Ω–∞—á–∏—Ç –ª–µ–Ω—Ç–∞ –Ω–µ –¥–æ–µ—Ö–∞–ª–∞
            // –ù–∞–º –Ω—É–∂–Ω–æ "–Ω–µ–¥–æ–µ—Ö–∞—Ç—å". –õ–µ–Ω—Ç–∞ –µ–¥–µ—Ç –≤–≤–µ—Ä—Ö (–∑–Ω–∞—á–µ–Ω–∏—è Y —É–º–µ–Ω—å—à–∞—é—Ç—Å—è).
            // –ó–Ω–∞—á–∏—Ç, —á—Ç–æ–±—ã –Ω–µ –¥–æ–µ—Ö–∞—Ç—å, Y –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ë–û–õ–¨–®–ï.
            initialY = baseTargetY + (itemHeight * profile.offsetPercent);
        }

        // 6. –ó–∞–ø—É—Å–∫
        strip.offsetHeight; // Reflow
        strip.style.transition = `transform ${profile.duration}ms ${profile.bezier}`;
        strip.style.transform = `translateY(${initialY}px)`;

        // –§—É–Ω–∫—Ü–∏—è —Ñ–∏–Ω–∞–ª–∞
        const finalize = () => {
            const winnerEl = strip.querySelectorAll('.roulette-item')[targetIndex];
            if(winnerEl) winnerEl.classList.add('winner');

            setTimeout(() => {
                mask.style.opacity = '0';
                mask.style.transition = 'opacity 0.2s';
                this.showPermanentBadge(container, targetNumber);
                
                container.dataset.hasAnimated = "true";
                container.classList.remove('spinning-active');
                setTimeout(() => mask.remove(), 200);
            }, 400);
        };

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–≤—É—Ö—ç—Ç–∞–ø–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
        if (profile.type === 'nudge') {
            // –ñ–¥–µ–º –ø–æ—á—Ç–∏ –¥–æ –∫–æ–Ω—Ü–∞ –∞–Ω–∏–º–∞—Ü–∏–∏
            setTimeout(() => {
                // "–î–æ–±–∏–≤–∞–µ–º" –≤ –Ω—É–∂–Ω—É—é –ø–æ–∑–∏—Ü–∏—é —Ä–µ–∑–∫–∏–º —É–¥–∞—Ä–æ–º
                strip.style.transition = 'transform 300ms cubic-bezier(0.5, 0, 0.5, 1)'; // –õ–∏–Ω–µ–π–Ω–æ-—É–¥–∞—Ä–Ω—ã–π
                strip.style.transform = `translateY(${baseTargetY}px)`;
                
                setTimeout(finalize, 300);
            }, profile.duration - 50); 
        } else {
            // –û–±—ã—á–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è
            setTimeout(finalize, profile.duration);
        }
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∑–Ω–∞—á–∫–∞ (–Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ)
    showPermanentBadge(container, value, instant = false) {
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π, –µ—Å–ª–∏ –µ—Å—Ç—å (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
        const old = container.querySelector('.roll-result-badge');
        if (old) old.remove();

        const badge = document.createElement('div');
        badge.className = 'roll-result-badge';
        badge.textContent = value;
        
        if (!instant) {
            badge.classList.add('spawn-anim');
            container.appendChild(badge);
            
            // Trigger anim
            requestAnimationFrame(() => {
                 badge.classList.remove('spawn-anim');
            });
        } else {
            container.appendChild(badge);
        }
    }

 

    updatePointsBar() {
        for (const currencyId in this.engine.state.currencies) {
            const span = document.querySelector(`#curr-${currencyId} span`);
            if (span) {
                const value = this.engine.state.currencies[currencyId];
                span.textContent = value;
                span.parentElement.classList.toggle('negative', value < 0);
            }
        }
    }

    updateBudgets() {
        for (const groupId in this.engine.state.budgets) {
            const group = this.engine.config.groups.find(g => g.id === groupId);
            if (group) {
                this.updateBudgetBadge(group);
            }
        }
    }

    updateBudgetBadge(group) {
        const badge = document.getElementById(`budget-${group.id}`);
        if (!badge) return;

        const budgetState = this.engine.state.budgets[group.id];
        if (!budgetState) {
            const budget = group.rules.budget;
            badge.textContent = `${budget.name || budget.currency}: ${budget.amount}/${budget.amount}`;
            return;
        }

        const { total, remaining } = budgetState;
        const budget = group.rules.budget;
        badge.textContent = `${budget.name || budget.currency}: ${remaining}/${total}`;
        badge.classList.toggle('empty', remaining === 0);
    }
}
</file>

<file path="src/ui/rule-builder.js">

/**
 * Rule Builder - Visual rule editor
 */

export class RuleBuilder {
    constructor(engine) {
        this.engine = engine;
        this.currentItem = null;
        this.currentGroup = null;
    }

    // ==================== RENDER UI ====================

    renderUI(container) {
        container.innerHTML = `
            <!-- Cost Section -->
            <div class="editor-section">
                <div class="accordion-header" onclick="CYOA.editor.toggleAccordion(this)">
                    üí∞ Cost
                </div>
                <div class="accordion-content">
                    <div id="cost-list" class="compact-list"></div>
                    <button class="full-width-btn" onclick="CYOA.editor.ruleBuilder.addCost()">+ Add Cost</button>
                </div>
            </div>
            
            <!-- Requirements Section -->
            <div class="editor-section">
                <div class="accordion-header collapsed" onclick="CYOA.editor.toggleAccordion(this)">
                    ‚úÖ Requirements
                </div>
                <div class="accordion-content collapsed">
                    <div id="requirements-list" class="compact-list"></div>
                    <button class="full-width-btn" onclick="CYOA.editor.ruleBuilder.addRequirement()">+ Add Requirement</button>
                </div>
            </div>

            <!-- Effects Section -->
            <div class="editor-section">
                <div class="accordion-header collapsed" onclick="CYOA.editor.toggleAccordion(this)">
                    ‚ö° Effects
                </div>
                <div class="accordion-content collapsed">
                    <div id="effects-list" class="compact-list"></div>
                    <button class="full-width-btn" onclick="CYOA.editor.ruleBuilder.addEffect()">+ Add Effect</button>
                </div>
            </div>
            
            <!-- Incompatible Section -->
            <div class="editor-section">
                <div class="accordion-header collapsed" onclick="CYOA.editor.toggleAccordion(this)">
                    ‚ùå Incompatible
                </div>
                <div class="accordion-content collapsed">
                    <div id="incompatible-list" class="compact-list"></div>
                    <button class="full-width-btn" onclick="CYOA.editor.ruleBuilder.addIncompatible()">+ Add Incompatible</button>
                </div>
            </div>
        `;
    }

    loadItem(item, group) {
        this.currentItem = item;
        this.currentGroup = group;
        this.renderCosts();
        this.renderRequirements();
        this.renderEffects();
        this.renderIncompatible();
    }

    // ==================== EFFECTS (UPDATED) ====================

    renderEffects() {
        if (!this.currentItem) return;
        const container = document.getElementById('effects-list');
        if (!container) return;
        const effects = this.currentItem.effects || [];
        
        if (effects.length === 0) {
            container.innerHTML = '<div style="color:#666; font-size:0.8rem; text-align:center; padding:2px;">No effects</div>';
            return;
        }

        container.innerHTML = effects.map((eff, index) => {
            let inputs = '';
            
            // 1. Modify Group Limit
            if (eff.type === 'modify_group_limit') {
                inputs = `
                    <select onchange="CYOA.editor.ruleBuilder.updateEffectProp(${index}, 'group_id', this.value)" style="width:100px;">
                        <option value="">Select Group...</option>
                        ${this.getGroupOptions(eff.group_id)}
                    </select>
                    <input type="number" value="${eff.value || 0}" 
                           onchange="CYOA.editor.ruleBuilder.updateEffectProp(${index}, 'value', this.value)"
                           placeholder="+/-" style="width:50px;">
                `;
            } 
            // 2. Force Selection
            else if (eff.type === 'force_selection') {
                inputs = `
                    <input type="text" value="${eff.target_id || ''}" 
                           onchange="CYOA.editor.ruleBuilder.updateEffectProp(${index}, 'target_id', this.value)"
                           placeholder="Target Item ID">
                `;
            } 
            // 3. Set Value
            else if (eff.type === 'set_value') {
                inputs = `
                    <select onchange="CYOA.editor.ruleBuilder.updateEffectProp(${index}, 'currency', this.value)" style="width:80px;">
                        ${this.getCurrencyOptions(eff.currency)}
                    </select>
                    <input type="number" value="${eff.value || 0}" 
                           onchange="CYOA.editor.ruleBuilder.updateEffectProp(${index}, 'value', this.value)"
                           placeholder="Val" style="width:50px;">
                `;
            }
            // 4. Modify Cost (NEW)
            else if (eff.type === 'modify_cost') {
                inputs = `
                    <input type="text" value="${eff.tag || ''}" 
                           onchange="CYOA.editor.ruleBuilder.updateEffectProp(${index}, 'tag', this.value)"
                           placeholder="Tag (e.g. magic)" style="width: 80px;">
                    
                    <select onchange="CYOA.editor.ruleBuilder.updateEffectProp(${index}, 'mode', this.value)" style="width:60px;">
                        <option value="add" ${(!eff.mode || eff.mode === 'add') ? 'selected' : ''}>Flat (+/-)</option>
                        <option value="multiply" ${eff.mode === 'multiply' ? 'selected' : ''}>% (Mult)</option>
                    </select>

                    <input type="number" value="${eff.value}" 
                           step="0.1"
                           onchange="CYOA.editor.ruleBuilder.updateEffectProp(${index}, 'value', this.value)"
                           placeholder="Val" style="width:50px;">
                `;
            }

            return `
            <div style="background:#222; padding:4px; border:1px solid #333; border-radius:4px; margin-bottom:4px;">
                <div class="compact-row">
                    <select onchange="CYOA.editor.ruleBuilder.updateEffectType(${index}, this.value)" style="font-weight:bold; color:#4CAF50;">
                        <option value="modify_group_limit" ${eff.type === 'modify_group_limit' ? 'selected' : ''}>Limit Mod</option>
                        <option value="modify_cost" ${eff.type === 'modify_cost' ? 'selected' : ''}>Cost Mod (Discount)</option>
                        <option value="force_selection" ${eff.type === 'force_selection' ? 'selected' : ''}>Force Select</option>
                        <option value="set_value" ${eff.type === 'set_value' ? 'selected' : ''}>Set Variable</option>
                    </select>
                    <button class="icon-btn" onclick="CYOA.editor.ruleBuilder.removeEffect(${index})">√ó</button>
                </div>
                <div style="display:flex; gap:4px; margin-top:4px;">
                    ${inputs}
                </div>
                ${eff.type === 'modify_cost' && eff.mode === 'multiply' ? '<div style="font-size:0.7em; color:#888;">0.5 = 50% discount</div>' : ''}
            </div>
            `;
        }).join('');
    }

    addEffect() {
        if (!this.currentItem) return;
        if (!this.currentItem.effects) this.currentItem.effects = [];
        
        // Default new effect
        this.currentItem.effects.push({ 
            type: 'modify_group_limit', 
            group_id: this.engine.config.groups[0]?.id || '',
            value: 1 
        });
        
        this.renderEffects();
        this.updateParent();
    }

    removeEffect(index) {
        if (!this.currentItem?.effects) return;
        this.currentItem.effects.splice(index, 1);
        this.renderEffects();
        this.updateParent();
    }

    updateEffectType(index, newType) {
        if (!this.currentItem?.effects?.[index]) return;
        
        // Reset props based on new type
        const newEffect = { type: newType };
        
        if (newType === 'modify_group_limit') {
            newEffect.group_id = this.engine.config.groups[0]?.id || '';
            newEffect.value = 1;
        } else if (newType === 'force_selection') {
            newEffect.target_id = '';
        } else if (newType === 'set_value') {
            newEffect.currency = 'points';
            newEffect.value = 0;
        } else if (newType === 'modify_cost') {
            newEffect.tag = 'magic';
            newEffect.mode = 'add'; // 'add' (flat) or 'multiply' (%)
            newEffect.value = 2;    // +2 points (flat) or 0.5 (50%)
        }
        
        this.currentItem.effects[index] = newEffect;
        this.renderEffects();
        this.updateParent();
    }

    updateEffectProp(index, prop, value) {
        if (!this.currentItem?.effects?.[index]) return;
        
        // Parse numbers
        if (prop === 'value') {
            const floatVal = parseFloat(value);
            value = isNaN(floatVal) ? 0 : floatVal;
        }
        
        this.currentItem.effects[index][prop] = value;
        this.updateParent();
    }

    // ==================== HELPERS ====================

    getCurrencyOptions(selected) {
        const currencies = this.engine.config.points || [];
        return currencies.map(c => 
            `<option value="${c.id}" ${c.id === selected ? 'selected' : ''}>${c.name}</option>`
        ).join('');
    }

    getGroupOptions(selected) {
        const groups = this.engine.config.groups || [];
        return groups.map(g => 
            `<option value="${g.id}" ${g.id === selected ? 'selected' : ''}>${g.title || g.id}</option>`
        ).join('');
    }
    
    // ... (COSTS & REQUIREMENTS & INCOMPATIBLE methods remain unchanged from previous versions)
    
    renderCosts() {
        if (!this.currentItem) return;
        const container = document.getElementById('cost-list');
        if (!container) return;
        const costs = this.currentItem.cost || [];
        if (costs.length === 0) {
            container.innerHTML = '<div style="color:#666; font-size:0.8rem; text-align:center; padding:2px;">No costs</div>';
            return;
        }
        container.innerHTML = costs.map((cost, index) => `
            <div class="compact-row">
                <select onchange="CYOA.editor.ruleBuilder.updateCostCurrency(${index}, this.value)" title="Currency">
                    ${this.getCurrencyOptions(cost.currency)}
                </select>
                <input type="text" value="${cost.value !== undefined ? cost.value : (cost.formula || 0)}" 
                       onchange="CYOA.editor.ruleBuilder.updateCostValueOrFormula(${index}, this.value)"
                       placeholder="Val">
                <button class="icon-btn" onclick="CYOA.editor.ruleBuilder.removeCost(${index})">√ó</button>
            </div>
        `).join('');
    }

    addCost() {
        if (!this.currentItem) return;
        if (!this.currentItem.cost) this.currentItem.cost = [];
        const firstCurrency = this.engine.config.points?.[0]?.id || 'points';
        this.currentItem.cost.push({ currency: firstCurrency, value: -1 });
        this.renderCosts();
        this.updateParent();
    }

    removeCost(index) {
        if (!this.currentItem?.cost) return;
        this.currentItem.cost.splice(index, 1);
        this.renderCosts();
        this.updateParent();
    }

    updateCostCurrency(index, value) {
        if (!this.currentItem?.cost?.[index]) return;
        this.currentItem.cost[index].currency = value;
        this.updateParent();
    }

    updateCostValueOrFormula(index, value) {
        if (!this.currentItem?.cost?.[index]) return;
        if (!isNaN(value) && value.trim() !== '') {
            this.currentItem.cost[index].value = parseInt(value);
            delete this.currentItem.cost[index].formula;
        } else {
            this.currentItem.cost[index].formula = value;
            delete this.currentItem.cost[index].value;
        }
        this.updateParent();
    }

    renderRequirements() {
        if (!this.currentItem) return;
        const container = document.getElementById('requirements-list');
        if (!container) return;
        const reqs = this.currentItem.requirements || [];
        if (reqs.length === 0) {
            container.innerHTML = '<div style="color:#666; font-size:0.8rem; text-align:center; padding:2px;">No requirements</div>';
            return;
        }
        container.innerHTML = reqs.map((req, index) => `
            <div class="compact-row" style="grid-template-columns: 1fr 24px;">
                <input type="text" value="${req}" 
                       onchange="CYOA.editor.ruleBuilder.updateRequirement(${index}, this.value)"
                       placeholder="item_id or count.tag('x')>1">
                <button class="icon-btn" onclick="CYOA.editor.ruleBuilder.removeRequirement(${index})">√ó</button>
            </div>
        `).join('');
    }

    addRequirement() {
        if (!this.currentItem) return;
        if (!this.currentItem.requirements) this.currentItem.requirements = [];
        this.currentItem.requirements.push('');
        this.renderRequirements();
        this.updateParent();
    }

    removeRequirement(index) {
        if (!this.currentItem?.requirements) return;
        this.currentItem.requirements.splice(index, 1);
        this.renderRequirements();
        this.updateParent();
    }

    updateRequirement(index, value) {
        if (!this.currentItem?.requirements) return;
        this.currentItem.requirements[index] = value;
        this.updateParent();
    }

    renderIncompatible() {
        if (!this.currentItem) return;
        const container = document.getElementById('incompatible-list');
        if (!container) return;
        const incomp = this.currentItem.incompatible || [];
        if (incomp.length === 0) {
            container.innerHTML = '<div style="color:#666; font-size:0.8rem; text-align:center; padding:2px;">No incompatibilities</div>';
            return;
        }
        container.innerHTML = incomp.map((id, index) => `
            <div class="compact-row" style="grid-template-columns: 1fr 24px;">
                <input type="text" value="${id}" 
                       onchange="CYOA.editor.ruleBuilder.updateIncompatible(${index}, this.value)"
                       placeholder="item_id">
                <button class="icon-btn" onclick="CYOA.editor.ruleBuilder.removeIncompatible(${index})">√ó</button>
            </div>
        `).join('');
    }

    addIncompatible() {
        if (!this.currentItem) return;
        if (!this.currentItem.incompatible) this.currentItem.incompatible = [];
        this.currentItem.incompatible.push('');
        this.renderIncompatible();
        this.updateParent();
    }

    removeIncompatible(index) {
        if (!this.currentItem?.incompatible) return;
        this.currentItem.incompatible.splice(index, 1);
        this.renderIncompatible();
        this.updateParent();
    }

    updateIncompatible(index, value) {
        if (!this.currentItem?.incompatible) return;
        this.currentItem.incompatible[index] = value;
        this.updateParent();
    }

    updateParent() {
        if (window.CYOA?.editor) {
            window.CYOA.editor.updateCodePreview();
            window.CYOA.editor.engine.recalculate();
            window.CYOA.editor.renderer.updateUI();
        }
    }
}
</file>

<file path="src/ui/tooltip.js">
/**
 * Tooltip Manager - Handles hover tooltips
 */

export class TooltipManager {
    constructor(engine) {
        this.engine = engine;
        this.tooltipEl = document.getElementById('tooltip');
        this.currentItem = null;
        this.currentGroup = null;
        this.timer = null;

        console.log('üí¨ Tooltip manager initialized');
    }

    // ==================== ATTACH ====================

    attach(element, item, group) {
        element.addEventListener('mouseenter', (e) => {
            this.currentItem = item;
            this.currentGroup = group;
            this.updateContent(item, group);
            this.updatePosition(e);

            // Delay show
            this.timer = setTimeout(() => {
                if (!document.body.classList.contains('text-mode')) {
                    this.show();
                }
            }, 300);
        });

        element.addEventListener('mousemove', (e) => {
            this.updatePosition(e);
        });

        element.addEventListener('mouseleave', () => {
            this.hide();
            this.currentItem = null;
            this.currentGroup = null;
            clearTimeout(this.timer);
        });
    }

    // ==================== SHOW/HIDE ====================

    show() {
        this.tooltipEl.classList.add('visible');
    }

    hide() {
        this.tooltipEl.classList.remove('visible');
    }

    // ==================== CONTENT ====================

    updateContent(item, group) {
        const isDebug = document.body.classList.contains('debug-mode') || document.body.classList.contains('edit-mode-active');
        let html = `<h4>${item.title}</h4>`;

        // 1. Tags
        if (item.tags && item.tags.length > 0) {
            html += this.renderTags(item);
        }

        // 2. Effects
        if (item.effects && item.effects.length > 0) {
            html += this.renderEffects(item);
        }

        // 3. Cost
        if (item.cost && item.cost.length > 0) {
            html += this.renderCost(item, group);
        }

        // 4. Requirements
        html += this.renderRequirements(item, group);

        // 5. Description
        if (!document.body.classList.contains('text-mode') && item.description) {
            html += `<div class="desc">${item.description}</div>`;
        }

        // 6. Debug info
        if (isDebug) {
            html += `<div class="debug-info">
                ID: ${item.id}<br>
                Group: ${group.id}<br>
                Coords: [${item.coords?.x}, ${item.coords?.y}, ${item.coords?.w}, ${item.coords?.h}]
            </div>`;
        }

        this.tooltipEl.innerHTML = html;
    }

    // ==================== RENDERERS ====================

    renderTags(item) {
        const tagsHtml = item.tags.map(t => 
            `<span style="background:#333; color:#aaa; padding:2px 6px; border-radius:4px; font-size:0.75em; margin-right:4px; border:1px solid #444;">${t}</span>`
        ).join('');
        return `<div style="margin-bottom:8px;">${tagsHtml}</div>`;
    }

    renderEffects(item) {
        let html = '<div style="margin-bottom:8px; border-top:1px solid #444; padding-top:4px;">';
        
        item.effects.forEach(eff => {
            let text = '';
            let icon = '‚ö°';

            switch (eff.type) {
                case 'modify_group_limit':
                    const group = this.engine.config.groups.find(g => g.id === eff.group_id);
                    const gName = group ? (group.title || eff.group_id) : eff.group_id;
                    const val = eff.value > 0 ? `+${eff.value}` : eff.value;
                    text = `Allows <b>${val}</b> more choices in <i>${gName}</i>`;
                    break;

                case 'modify_cost':
                    const target = eff.tag ? `[${eff.tag}]` : (eff.group_id ? `Group` : 'items');
                    if (eff.mode === 'multiply') {
                        const percent = Math.round((1 - eff.value) * 100);
                        text = `<b>${percent}% Discount</b> on ${target} items`;
                    } else {
                        const sign = eff.value > 0 ? 'Discount' : 'Markup';
                        text = `<b>${Math.abs(eff.value)} point ${sign}</b> on ${target} items`;
                    }
                    icon = 'üè∑Ô∏è';
                    break;

                case 'force_selection':
                    const forcedItem = this.engine.findItem(eff.target_id);
                    const name = forcedItem ? forcedItem.title : eff.target_id;
                    text = `Automatically adds: <b>${name}</b>`;
                    icon = 'üéÅ';
                    break;

                case 'set_value':
                    text = `Sets <b>${eff.currency}</b> to ${eff.value}`;
                    break;

                case 'roll_dice':
                    // Check if already rolled
                    const current = this.engine.state.rollResults.get(item.id);
                    const range = `${eff.min || 1}-${eff.max || 6}`;
                    if (current !== undefined) {
                        text = `Rolled Result: <b>${current}</b> ${eff.currency}`;
                        icon = 'üé≤';
                    } else {
                        text = `Rolls <b>${range}</b> ${eff.currency}`;
                        icon = 'üé≤';
                    }
                    break;

                default:
                    text = `Unknown Effect: ${eff.type}`;
            }

            html += `<div style="color:#4db8ff; font-size:0.9em; margin-bottom:2px;">${icon} ${text}</div>`;
        });

        html += '</div>';
        return html;
    }

    renderCost(item, group) {
        let html = '';
        item.cost.forEach(c => {
            const { value, modifiers } = this.engine.rules.getCostBreakdown(c, item, group);
            const sign = value > 0 ? '+' : '';
            
            let colorClass = value < 0 ? 'bad' : ''; 
            if (value === 0) colorClass = 'free';      
            if (value > 0) colorClass = 'good';        

            let modHtml = '';
            if (modifiers.length > 0) {
                modHtml = `<span class="mod-applied">(${modifiers.join(' ')})</span>`;
            }

            html += `<div class="cost ${colorClass}">
                ${c.currency}: ${sign}${value} ${modHtml}
            </div>`;
        });
        return html;
    }

    renderRequirements(item, group) {
        let reqsHtml = '';

        if (item.incompatible) {
            item.incompatible.forEach(badId => {
                if (this.engine.state.selected.has(badId)) {
                    const badItem = this.engine.findItem(badId);
                    reqsHtml += `<span class="req-item fail">‚ùå Incompatible with: ${badItem?.title || badId}</span>`;
                }
            });
        }

        const isSelected = this.engine.state.selected.has(item.id);
        if (!isSelected && group.rules?.max_choices) {
            const currentCount = this.engine.getSelectedInGroup(group).length;
            if (currentCount >= group.rules.max_choices) {
                reqsHtml += `<span class="req-item fail">‚õî Max choices reached (${group.rules.max_choices})</span>`;
            }
        }

        if (item.requirements) {
            item.requirements.forEach(req => {
                reqsHtml += this.renderRequirement(req);
            });
        }

        if (reqsHtml) {
            return `<div class="reqs">${reqsHtml}</div>`;
        }
        return '';
    }

    renderRequirement(req) {
        let isMet = false;
        let displayText = req;

        const formatText = (txt) => {
            return txt
                .replace(/count\.tag\(['"](.+?)['"]\)/g, "Tag: $1")
                .replace(/count\.([a-zA-Z0-9_]+)/g, "Group: $1")
                .replace(/has\(['"](.+?)['"]\)/g, "$1")
                .replace(/\|\|/g, " OR ")
                .replace(/&&/g, " AND ")
                .replace(/>=/g, "‚â•")
                .replace(/<=/g, "‚â§");
        };

        if (req.includes('(') || req.includes('||') || req.includes('&&') || req.includes('count.')) {
            isMet = this.engine.rules.evaluateRequirement(req, null);
            displayText = formatText(req);
        } else {
            const isNot = req.startsWith('!');
            const cleanId = isNot ? req.slice(1) : req;
            const targetSelected = this.engine.state.selected.has(cleanId);
            isMet = isNot ? !targetSelected : targetSelected;
            const targetItem = this.engine.findItem(cleanId);
            const name = targetItem?.title || cleanId;
            displayText = (isNot ? "NOT " : "") + name;
        }

        if (!isMet) {
            return `<span class="req-item missing">‚ö†Ô∏è Requires: ${displayText}</span>`;
        } else {
            return `<span class="req-item ok">‚úî ${displayText}</span>`;
        }
    }

    updatePosition(e) {
        const tt = this.tooltipEl;
        const ttH = tt.offsetHeight;
        const ttW = tt.offsetWidth;

        let top = e.clientY + 20;
        let left = e.clientX + 20;

        if (left + ttW > window.innerWidth) {
            left = window.innerWidth - ttW - 20;
        }
        if (top + ttH > window.innerHeight) {
            top = e.clientY - ttH - 10;
        }

        tt.style.top = top + 'px';
        tt.style.left = left + 'px';
    }
}
</file>

<file path="src/utils/autodetect.js">
/**
 * AutoDetect - SAM3 Integration logic
 * Optimized: Smart Downscaling + Sliding Window Morphology
 */

import { Client } from "@gradio/client";

export class AutoDetector {
    constructor() {
        this.client = null;
        this.statusCallback = null;
        this.debugCallback = null;
        
        // –£–≤–µ–ª–∏—á–∏–ª–∏ –ª–∏–º–∏—Ç –¥–æ 2000px. 
        // –≠—Ç–æ –¥–∞–µ—Ç –≤—ã—Å–æ–∫—É—é —Ç–æ—á–Ω–æ—Å—Ç—å, –∞ –∞–ª–≥–æ—Ä–∏—Ç–º "—Å–∫–æ–ª—å–∑—è—â–µ–≥–æ –æ–∫–Ω–∞" 
        // —Å–ø—Ä–∞–≤–∏—Ç—Å—è —Å —Ç–∞–∫–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é –±–µ–∑ –ø—Ä–æ–±–ª–µ–º.
        this.MAX_PROCESSING_SIZE = 2000;
    }

    setStatus(msg) {
        if (this.statusCallback) this.statusCallback(msg);
        console.log(`ü§ñ AutoDetect: ${msg}`);
    }

    sendDebugImage(title, canvas) {
        if (this.debugCallback) {
            this.debugCallback(title, canvas.toDataURL('image/png'));
        }
    }

    /**
     * Main function to process image
     */
    async processImage(imageFile, prompt, shaveRatio, hfToken, targetDebugIndex = -1) {
        if (!this.client) {
            try {
                this.setStatus("Connecting to SAM3...");
                this.client = await Client.connect("akhaliq/sam3", { hf_token: hfToken });
            } catch (e) {
                this.setStatus(`Connection Failed: ${e.message}`);
                return [];
            }
        }

        this.setStatus("Sending image to SAM3...");
        
        try {
            const result = await this.client.predict("/segment", { 
                image: imageFile, 
                text: prompt,
                threshold: 0.3, 
                mask_threshold: 0.5 
            });

            const rawAnnotations = result.data[0].annotations;
            if (!rawAnnotations || rawAnnotations.length === 0) {
                this.setStatus("No elements found.");
                return [];
            }

            // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –±–∏—Ç–º–∞–ø–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞ –¥–ª—è —Ä–∞–∑–º–µ—Ä–æ–≤
            const imgBitmap = await createImageBitmap(imageFile);
            const originalW = imgBitmap.width;
            const originalH = imgBitmap.height;

            // –í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—à—Ç–∞–± –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è
            const scale = this.calculateScale(originalW, originalH);
            const processW = Math.round(originalW * scale);
            const processH = Math.round(originalH * scale);

            this.setStatus(`Processing ${rawAnnotations.length} masks. Scale: ${scale.toFixed(3)} (${processW}x${processH})`);

            const detectedItems = [];

            for (let i = 0; i < rawAnnotations.length; i++) {
                this.setStatus(`Processing mask ${i+1}/${rawAnnotations.length}...`);
                
                const isDebugItem = (targetDebugIndex >= 0 && i === targetDebugIndex);

                // –î–∞—ë–º –±—Ä–∞—É–∑–µ—Ä—É "–≤–∑–¥–æ—Ö–Ω—É—Ç—å" –∫–∞–∂–¥—ã–µ 3 –º–∞—Å–∫–∏, —á—Ç–æ–±—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –Ω–µ —Ñ—Ä–∏–∑–∏–ª—Å—è
                if (i > 0 && i % 3 === 0) {
                    await this.yieldToMain();
                }

                const bbox = await this.processMaskMorphologyOptimized(
                    rawAnnotations[i].image.url, 
                    originalW, originalH,
                    processW, processH,
                    scale,
                    shaveRatio, 
                    isDebugItem ? `Item ${i+1}` : null
                );
                
                if (bbox) {
                    detectedItems.push({
                        id: `item_${String(i + 1).padStart(3, '0')}`,
                        title: `Item ${i + 1}`,
                        coords: bbox
                    });
                }
            }

            // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ (—Å—Ç—Ä–æ–∫–∏ -> –∫–æ–ª–æ–Ω–∫–∏)
            const ROW_TOLERANCE = 50;
            detectedItems.sort((a, b) => {
                const rowA = Math.floor(a.coords.y / ROW_TOLERANCE);
                const rowB = Math.floor(b.coords.y / ROW_TOLERANCE);
                if (rowA !== rowB) return rowA - rowB;
                return a.coords.x - b.coords.x;
            });

            // –ü–µ—Ä–µ–Ω—É–º–µ—Ä–∞—Ü–∏—è –ø–æ—Å–ª–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
            detectedItems.forEach((item, idx) => {
                item.id = `item_${String(idx + 1).padStart(3, '0')}`;
                item.title = `Item ${idx + 1}`;
            });

            this.setStatus("Done!");
            return detectedItems;

        } catch (e) {
            console.error(e);
            this.setStatus(`Error: ${e.message}`);
            return [];
        }
    }

    calculateScale(w, h) {
        const maxDim = Math.max(w, h);
        if (maxDim <= this.MAX_PROCESSING_SIZE) {
            return 1; // –ù–µ –Ω—É–∂–Ω–æ —É–º–µ–Ω—å—à–∞—Ç—å
        }
        return this.MAX_PROCESSING_SIZE / maxDim;
    }

    /**
     * –ü–æ–∑–≤–æ–ª—è–µ—Ç –±—Ä–∞—É–∑–µ—Ä—É –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å UI —Å–æ–±—ã—Ç–∏—è, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Ñ—Ä–∏–∑–æ–≤
     */
    yieldToMain() {
        return new Promise(resolve => {
            if ('scheduler' in window && 'yield' in window.scheduler) {
                window.scheduler.yield().then(resolve);
            } else {
                setTimeout(resolve, 0);
            }
        });
    }

    async processMaskMorphologyOptimized(maskUrl, originalW, originalH, processW, processH, scale, shaveRatio, debugName) {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = maskUrl;
            
            img.onload = () => {
                // 1. –°–æ–∑–¥–∞—ë–º canvas —É–º–µ–Ω—å—à–µ–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
                const canvas = document.createElement('canvas');
                canvas.width = processW;
                canvas.height = processH;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                
                // –†–∏—Å—É–µ–º –º–∞—Å–∫—É
                ctx.drawImage(img, 0, 0, processW, processH);

                if (debugName) {
                    this.sendDebugImage(`${debugName} - 1. Original (${processW}√ó${processH})`, canvas);
                }

                // 2. –ü–æ–ª—É—á–∞–µ–º –ø–∏–∫—Å–µ–ª–∏
                const imgData = ctx.getImageData(0, 0, processW, processH);
                let binary = new Uint8Array(processW * processH);
                
                const data = imgData.data;
                const len = binary.length;
                for (let k = 0; k < len; k++) {
                    binary[k] = data[k << 2] > 128 ? 1 : 0; 
                }

                // ==========================================
                // STEP 3: MORPH OPEN (Shaving)
                // ==========================================
                
                let shaveSize = Math.floor(processW * shaveRatio);
                if (shaveSize < 3) shaveSize = 3;
                if (shaveSize % 2 === 0) shaveSize++;

                let eroded = this.morphErodeOptimized(binary, processW, processH, shaveSize);
                let shaved = this.morphDilateOptimized(eroded, processW, processH, shaveSize);

                if (debugName) {
                    this.drawBinaryToCanvas(shaved, ctx, processW, processH);
                    this.sendDebugImage(`${debugName} - 2. Shaved (K=${shaveSize})`, canvas);
                }

                // ==========================================
                // STEP 4: MORPH CLOSE (Closing holes)
                // ==========================================
                let closeSize = Math.max(3, Math.round(15 * scale)); 
                if (closeSize % 2 === 0) closeSize++;
                
                let dilated2 = this.morphDilateOptimized(shaved, processW, processH, closeSize);
                let closed = this.morphErodeOptimized(dilated2, processW, processH, closeSize);

                if (debugName) {
                    this.drawBinaryToCanvas(closed, ctx, processW, processH);
                    this.sendDebugImage(`${debugName} - 3. Closed (Final)`, canvas);
                }

                // ==========================================
                // STEP 5: Find BBox –≤ —É–º–µ–Ω—å—à–µ–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
                // ==========================================
                const bboxSmall = this.findBoundingBoxOptimized(closed, processW, processH);
                
                if (bboxSmall) {
                    // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–±—Ä–∞—Ç–Ω–æ –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º—É —Ä–∞–∑–º–µ—Ä—É
                    const bbox = {
                        x: Math.round(bboxSmall.x / scale),
                        y: Math.round(bboxSmall.y / scale),
                        w: Math.round(bboxSmall.w / scale),
                        h: Math.round(bboxSmall.h / scale)
                    };
                    
                    const area = bbox.w * bbox.h;
                    const minArea = (originalW * originalH) * 0.0005;
                    
                    if (area < minArea) {
                        resolve(null);
                    } else {
                        resolve(bbox);
                    }
                } else {
                    resolve(null);
                }
            };
            img.onerror = () => resolve(null);
        });
    }

    drawBinaryToCanvas(binary, ctx, w, h) {
        const output = ctx.createImageData(w, h);
        const outData = output.data;
        const len = binary.length;
        
        for (let i = 0; i < len; i++) {
            const val = binary[i] === 1 ? 255 : 0;
            const idx = i << 2; 
            outData[idx] = val;
            outData[idx + 1] = val;
            outData[idx + 2] = val;
            outData[idx + 3] = 255;
        }
        ctx.putImageData(output, 0, 0);
    }

    findBoundingBoxOptimized(binary, w, h) {
        let minX = w, minY = h, maxX = -1, maxY = -1;
        
        // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–∏—Å–∫ –≥—Ä–∞–Ω–∏—Ü
        let foundFirst = false;
        for (let y = 0; y < h && !foundFirst; y++) {
            const rowStart = y * w;
            for (let x = 0; x < w; x++) {
                if (binary[rowStart + x] === 1) {
                    minY = y;
                    foundFirst = true;
                    break;
                }
            }
        }
        
        if (!foundFirst) return null;
        
        for (let y = h - 1; y >= minY; y--) {
            const rowStart = y * w;
            for (let x = 0; x < w; x++) {
                if (binary[rowStart + x] === 1) {
                    maxY = y;
                    break;
                }
            }
            if (maxY !== -1) break;
        }
        
        for (let y = minY; y <= maxY; y++) {
            const rowStart = y * w;
            for (let x = 0; x < w; x++) {
                if (binary[rowStart + x] === 1) {
                    if (x < minX) minX = x;
                    break;
                }
            }
            for (let x = w - 1; x >= 0; x--) {
                if (binary[rowStart + x] === 1) {
                    if (x > maxX) maxX = x;
                    break;
                }
            }
        }
        
        if (maxX < 0) return null;
        return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
    }

    /**
     * –°—É–ø–µ—Ä-–±—ã—Å—Ç—Ä–∞—è —ç—Ä–æ–∑–∏—è (Sliding Window)
     * O(N) –≤–º–µ—Å—Ç–æ O(N*K)
     */
    morphErodeOptimized(input, w, h, kSize) {
        const r = kSize >> 1; 
        const temp = new Uint8Array(w * h);
        const output = new Uint8Array(w * h);

        // Pass 1: Horizontal
        for (let y = 0; y < h; y++) {
            const rowStart = y * w;
            let count = 0;
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
            for (let x = 0; x < r; x++) {
                count += input[rowStart + x];
            }
            
            for (let x = 0; x < w; x++) {
                if (x + r < w) {
                    count += input[rowStart + x + r];
                }
                
                const left = x - r;
                const right = Math.min(x + r, w - 1);
                const windowSize = right - Math.max(0, left) + 1;
                
                // –ï—Å–ª–∏ —Å—É–º–º–∞ –≤ –æ–∫–Ω–µ —Ä–∞–≤–Ω–∞ —Ä–∞–∑–º–µ—Ä—É –æ–∫–Ω–∞, –∑–Ω–∞—á–∏—Ç –≤—Å–µ –ø–∏–∫—Å–µ–ª–∏ = 1
                temp[rowStart + x] = (count === windowSize) ? 1 : 0;
                
                if (left >= 0) {
                    count -= input[rowStart + left];
                }
            }
        }

        // Pass 2: Vertical
        for (let x = 0; x < w; x++) {
            let count = 0;
            
            for (let y = 0; y < r; y++) {
                count += temp[y * w + x];
            }
            
            for (let y = 0; y < h; y++) {
                if (y + r < h) {
                    count += temp[(y + r) * w + x];
                }
                
                const top = y - r;
                const bottom = Math.min(y + r, h - 1);
                const windowSize = bottom - Math.max(0, top) + 1;
                
                output[y * w + x] = (count === windowSize) ? 1 : 0;
                
                if (top >= 0) {
                    count -= temp[top * w + x];
                }
            }
        }
        return output;
    }

    /**
     * –°—É–ø–µ—Ä-–±—ã—Å—Ç—Ä–∞—è –¥–∏–ª–∞—Ç–∞—Ü–∏—è (Sliding Window)
     */
    morphDilateOptimized(input, w, h, kSize) {
        const r = kSize >> 1;
        const temp = new Uint8Array(w * h);
        const output = new Uint8Array(w * h);

        // Pass 1: Horizontal
        for (let y = 0; y < h; y++) {
            const rowStart = y * w;
            let count = 0;
            
            for (let x = 0; x < r; x++) {
                count += input[rowStart + x];
            }
            
            for (let x = 0; x < w; x++) {
                if (x + r < w) {
                    count += input[rowStart + x + r];
                }
                
                // –ï—Å–ª–∏ —Å—É–º–º–∞ > 0, –∑–Ω–∞—á–∏—Ç —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –ø–∏–∫—Å–µ–ª—å = 1
                temp[rowStart + x] = (count > 0) ? 1 : 0;
                
                const left = x - r;
                if (left >= 0) {
                    count -= input[rowStart + left];
                }
            }
        }

        // Pass 2: Vertical
        for (let x = 0; x < w; x++) {
            let count = 0;
            
            for (let y = 0; y < r; y++) {
                count += temp[y * w + x];
            }
            
            for (let y = 0; y < h; y++) {
                if (y + r < h) {
                    count += temp[(y + r) * w + x];
                }
                
                output[y * w + x] = (count > 0) ? 1 : 0;
                
                const top = y - r;
                if (top >= 0) {
                    count -= temp[top * w + x];
                }
            }
        }
        return output;
    }
}
</file>

<file path="src/utils/coords.js">
/**
 * Coordinate Helper - Converts between pixels and percentages
 */

export class CoordHelper {
    /**
     * Convert coordinates to percentage
     * @param {Object|Array} coords - {x, y, w, h} or [x, y, w, h]
     * @param {Object} dimensions - {w, h} of image
     * @returns {Object} CSS style object
     */
    static toPercent(coords, dimensions) {
        if (!coords || !dimensions) {
            return { display: 'none' };
        }

        // Normalize to object
        const raw = Array.isArray(coords)
            ? { x: coords[0], y: coords[1], w: coords[2], h: coords[3] }
            : { ...coords };

        // Auto-detect: if any value > 100, assume pixels
        const isPixels = raw.x > 100 || raw.y > 100 || raw.w > 100 || raw.h > 100;

        if (isPixels) {
            return {
                left: (raw.x / dimensions.w * 100) + '%',
                top: (raw.y / dimensions.h * 100) + '%',
                width: (raw.w / dimensions.w * 100) + '%',
                height: (raw.h / dimensions.h * 100) + '%'
            };
        }

        // Already percentages
        return {
            left: raw.x + '%',
            top: raw.y + '%',
            width: raw.w + '%',
            height: raw.h + '%'
        };
    }

    /**
     * Convert coordinates to pixels
     */
    static toPixels(coords, dimensions) {
        const raw = Array.isArray(coords)
            ? { x: coords[0], y: coords[1], w: coords[2], h: coords[3] }
            : { ...coords };

        const isPixels = raw.x > 100 || raw.y > 100 || raw.w > 100 || raw.h > 100;

        if (isPixels) {
            return raw;
        }

        return {
            x: raw.x / 100 * dimensions.w,
            y: raw.y / 100 * dimensions.h,
            w: raw.w / 100 * dimensions.w,
            h: raw.h / 100 * dimensions.h
        };
    }
}
</file>

<file path="src/utils/evaluator.js">

</file>

<file path="styles/main.css">
/* ==========================================================================
   CYOA INTERACTIVE STYLES
   ========================================================================== */

/* === RESET & BASE === */
* { box-sizing: border-box; }
body { margin: 0; padding: 0 0 120px 0; background: #1a1a1a; color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow-x: hidden; }
#loading { transition: opacity 0.3s; }
#loading.hidden { opacity: 0; pointer-events: none; }

/* === TOP CONTROLS === */
.top-controls { position: fixed; top: 10px; right: 10px; z-index: 3000; display: flex; gap: 10px; }
.ctrl-btn { background: #333; color: #fff; border: 1px solid #555; padding: 8px 15px; cursor: pointer; border-radius: 4px; transition: all 0.2s; opacity: 0.85; font-weight: bold; }
.ctrl-btn:hover { opacity: 1; background: #444; transform: translateY(-1px); }
.ctrl-btn.active { background: #0066cc; border-color: #0088ff; opacity: 1; }

/* === GAME WRAPPER & PAGE === */
#game-wrapper { position: relative; max-width: 100%; margin: 0 auto; display: flex; flex-direction: column; align-items: center; }
.page-container { position: relative; margin-bottom: 0; line-height: 0; box-shadow: 0 0 30px rgba(0,0,0,0.5); max-width: 100%; }
.page-image { display: block; max-width: 100%; height: auto; user-select: none; }
.page-layer { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 10; pointer-events: none; }

/* === CLICK ZONES & BUTTONS === */
.click-zone { 
    position: absolute; 
    cursor: pointer; 
    z-index: 100; 
    pointer-events: auto; 
    border-radius: 12px; 
    transition: all 0.2s; 
    /* CHANGED: Allowed overflow so the badge can stick out */
    overflow: visible; 
    display: flex; 
    flex-direction: column; 
    justify-content: flex-end; 
}
.click-zone:hover { background: rgba(255,255,255,0.07); box-shadow: 0 0 10px rgba(255,255,255,0.1); }
.click-zone.selected { background: rgba(0,255,0,0.1); box-shadow: 0 0 15px 2px #0f0, inset 0 0 20px 5px rgba(0,255,0,0.3); }
.click-zone.disabled { cursor: not-allowed; background-image: repeating-linear-gradient(45deg, rgba(0,0,0,0.4), rgba(0,0,0,0.4) 10px, rgba(50,50,50,0.6) 10px, rgba(50,50,50,0.6) 20px); box-shadow: 0 0 15px 5px #000, inset 0 0 20px 10px rgba(0,0,0,0.8); }
.click-zone.maxed { background: rgba(0,255,0,0.05); cursor: default; } /* Max quantity reached */

.info-zone { z-index: 50; pointer-events: none; border: none; }
.info-zone .text-content { pointer-events: auto; }





/* ==========================================================================
   ROULETTE & DICE STYLES (Clean UI)
   ========================================================================== */

.roulette-mask {
    position: absolute;
    top: 5px; left: 0; right: 0; bottom: 5px; /* –ù–∞ –≤—Å—é –≤—ã—Å–æ—Ç—É */
    overflow: hidden;
    background: transparent; /* –£–ë–†–ê–ù –¢–ï–ú–ù–´–ô –§–û–ù */
    z-index: 200;
    pointer-events: none;
    
    /* –ú—è–≥–∫–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ –∫—Ä–∞—è—Ö, —á—Ç–æ–±—ã —Å–∫—Ä—ã—Ç—å —Ä–µ–∑–∫–æ–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ */
    mask-image: linear-gradient(to bottom, 
        transparent 0%, 
        black 15%, 
        black 85%, 
        transparent 100%
    );
    -webkit-mask-image: linear-gradient(to bottom, 
        transparent 0%, 
        black 15%, 
        black 85%, 
        transparent 100%
    );
}

.roulette-strip {
    will-change: transform;
    /* –£–±–∏—Ä–∞–µ–º —Ä–∞–∑–º—ã—Ç–∏–µ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –¥–ª—è —á–µ—Ç–∫–æ—Å—Ç–∏, –∏–ª–∏ –¥–æ–±–∞–≤–ª—è–µ–º –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏ */
    /* filter: blur(0px); */ 
}

.roulette-item {
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    
    font-family: 'Impact', 'Arial Black', sans-serif;
    font-size: 3.5rem; 
    line-height: 1;
    color: #fff;
    
    /* –ò–ú–ò–¢–ê–¶–ò–Ø –û–ë–í–û–î–ö–ò (STROKE) */
    /* –¢–µ–Ω—å —Å–æ –≤—Å–µ—Ö —Å—Ç–æ—Ä–æ–Ω —Å–æ–∑–¥–∞–µ—Ç –∂–µ—Å—Ç–∫–∏–π –∫–æ–Ω—Ç—É—Ä */
    text-shadow: 
        3px 3px 0 #000,
        -1px -1px 0 #000,  
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000;
        
 
}

.roulette-item.winner {
    color: #ffd700;
    /* –£—Å–∏–ª–∏–≤–∞–µ–º —Å–≤–µ—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–±–µ–¥–µ */
    text-shadow: 
        3px 3px 0 #000,
        -1px -1px 0 #000,
        0 0 20px #ffd700;
    transform: scale(1.1); /* –õ–µ–≥–∫–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ */
    transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* –§–∏–Ω–∞–ª—å–Ω—ã–π –±–µ–π–¥–∂ –æ—Å—Ç–∞–µ—Ç—Å—è —Ç–µ–º –∂–µ, –æ–Ω —Ö–æ—Ä–æ—à–∏–π */
.roll-result-badge {
    position: absolute;
    top: 0; left: 50%;
    transform: translate(-50%, -50%) scale(1);
    width: 50px; height: 50px;
    background: #111;
    border: 3px solid #ffd700;
    border-radius: 50%;
    box-shadow: 0 0 10px rgba(0,0,0,0.8), 0 0 20px rgba(255, 215, 0, 0.4);
    color: #ffd700;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Impact', sans-serif;
    font-size: 24px;
    z-index: 300;
    pointer-events: none;
    user-select: none;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.roll-result-badge.spawn-anim {
    top: 50%;
    transform: translate(-50%, -50%) scale(2.0);
    opacity: 0;
}

.roulette-mask, .roulette-strip, .roulette-item, .roll-result-badge {
    /* –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å */
    user-select: none;
    
    /* –î–ª—è Safari –∏ Chrome */
    -webkit-user-select: none;
    
    /* –î–ª—è Firefox */
    -moz-user-select: none;
    
    /* –î–ª—è —Å—Ç–∞—Ä—ã—Ö IE/Edge */
    -ms-user-select: none;
    
    /* –û—Ç–∫–ª—é—á–∞–µ–º –º–µ–Ω—é –ø—Ä–∏ –¥–æ–ª–≥–æ–º —Ç–∞–ø–µ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
    -webkit-touch-callout: none; 
}

/* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —É–±–µ–¥–∏–º—Å—è, —á—Ç–æ –∫—É—Ä—Å–æ—Ä –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã–π */
.roulette-item {
    cursor: default;
}







/* === MULTI-SELECT CONTROLS === */
.split-controls { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; z-index: 150; }
.split-btn { width: 50%; height: 100%; transition: background 0.2s, opacity 0.2s; display: flex; align-items: center; justify-content: center; font-size: 40px; font-weight: bold; opacity: 0; color: rgba(255,255,255,0.8); text-shadow: 0 0 5px #000; }
.split-btn:hover { opacity: 1; }
.split-btn.minus:hover { background: rgba(255,0,0,0.2); }
.split-btn.minus:hover::after { content: '-'; }
.split-btn.plus:hover { background: rgba(0,255,0,0.2); }
.split-btn.plus:hover::after { content: '+'; }

.qty-badge { position: absolute; top: 10px; right: 10px; width: 40px; height: 40px; background: #000; border: 2px solid #0f0; border-radius: 50%; color: #0f0; font-weight: bold; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 160; box-shadow: 0 0 10px rgba(0,255,0,0.5); pointer-events: none; }

/* === TEXT LAYER === */
.text-content { display: none; background: rgba(0,0,0,0.85); color: #ddd; padding: 10px; font-size: 14px; line-height: 1.4; max-height: 100%; overflow-y: auto; pointer-events: none; backdrop-filter: blur(2px); border-top: 1px solid #444; position: relative; z-index: 10; }
.text-content strong { display: block; color: #fff; font-size: 1.1em; margin-bottom: 4px; border-bottom: 1px solid #555; }
body.text-mode .text-content { display: block; pointer-events: auto; }

/* === BADGES & POINTS === */
.group-budget-badge { position: absolute; transform: translate(-50%, -50%); background: #000; border: 2px solid #ffd700; color: #ffd700; padding: 8px 20px; border-radius: 8px; font-weight: 800; font-size: 18px; z-index: 200; pointer-events: none; white-space: nowrap; box-shadow: 0 0 20px 2px rgba(255,215,0,0.6); }
.group-budget-badge.empty { border-color: #444; color: #666; background: rgba(0,0,0,0.8); box-shadow: none; }
#points-bar { position: fixed; bottom: 0; left: 0; right: 0; background: #101010; border-top: 1px solid #333; padding: 15px; display: flex; justify-content: center; gap: 40px; box-shadow: 0 -5px 30px rgba(0,0,0,0.8); z-index: 2000; flex-wrap: wrap; }
.currency { font-size: 1.2em; font-weight: bold; text-transform: uppercase; display: flex; align-items: center; gap: 10px; }
.currency span { color: #00ff88; font-family: monospace; font-size: 1.3em; text-shadow: 0 0 5px rgba(0,255,100,0.5); }
.currency.negative span { color: #ff4444; text-shadow: 0 0 5px rgba(255,50,50,0.5); }

/* === TOOLTIP === */
#tooltip { position: fixed; z-index: 3000; background: rgba(10,10,10,0.95); border: 1px solid #444; padding: 15px; border-radius: 8px; pointer-events: none; font-size: 0.95em; max-width: 380px; box-shadow: 0 10px 40px #000; backdrop-filter: blur(8px); opacity: 0; transition: opacity 0.2s; color: #ccc; }
#tooltip.visible { opacity: 1; }
#tooltip h4 { margin: 0 0 8px 0; color: #fff; border-bottom: 1px solid #333; padding-bottom: 6px; }
#tooltip .cost { color: #0f0; font-weight: bold; margin-top: 8px; }
#tooltip .cost.bad { color: #f66; }
#tooltip .req-item.fail { color: #f88; font-weight: bold; }
#tooltip .req-item.ok { color: #666; text-decoration: line-through; }
#tooltip .debug-info { margin-top: 10px; padding-top: 10px; border-top: 1px dashed #555; color: #777; font-size: 0.75em; font-family: monospace; }
#tooltip .mod-applied { color: #4db8ff; font-size: 0.85em; font-weight: normal; margin-left: 6px; font-family: monospace;}

/* === EDIT MODE VISUALS (Toggle via Edit Button) === */
body.show-zones .click-zone { border: 2px solid rgba(255,0,0,0.5) !important; background: rgba(255,0,0,0.05) !important; border-radius: 0 !important; box-shadow: none !important; }
body.show-zones .click-zone::after { content: attr(id); position: absolute; top: 0; left: 0; background: red; color: white; font-size: 10px; padding: 1px 3px; pointer-events: none; }
body.show-zones .info-zone { border: 2px dashed rgba(255,165,0,0.4) !important; background: rgba(255,165,0,0.1) !important; }

/* === EDIT MODE INTERACTION (Depends on active Tab) === */
body.edit-mode-choice .item-zone { pointer-events: auto; cursor: move; }
body.edit-mode-choice .info-zone { pointer-events: none; }
body.edit-mode-group .info-zone { pointer-events: auto; cursor: move; z-index: 2000; } 
body.edit-mode-group .item-zone { pointer-events: none; opacity: 0.5; }

/* === SELECTION HIGHLIGHTS === */
.item-zone.editor-selected { border: 3px solid #FFD700 !important; box-shadow: 0 0 20px rgba(255,215,0,0.5) !important; z-index: 3000; }
.info-zone.editor-selected { border: 3px solid #4CAF50 !important; background: rgba(76,175,80,0.2) !important; z-index: 3000; }
.editor-selected::after { content: ''; position: absolute; right: 0; bottom: 0; width: 15px; height: 15px; background: #fff; border: 1px solid #000; cursor: nwse-resize; pointer-events: none; }
.click-zone.dragging { transition: none !important; z-index: 9999 !important; pointer-events: none; opacity: 0.8; }

/* === EDITOR SIDEBAR LAYOUT === */
.editor-sidebar { background: #1a1a1a; width: 340px; position: fixed; right: 0; top: 0; bottom: 0; z-index: 4000; display: flex; flex-direction: column; box-shadow: -5px 0 20px rgba(0,0,0,0.5); border-left: 1px solid #333; }
body.edit-mode-active #game-wrapper { margin-right: 340px; transition: margin-right 0.3s; }

/* === EDITOR TABS === */
.editor-tabs { display: flex; background: #111; border-bottom: 1px solid #333; }
.tab-btn { flex: 1; background: #111; border: none; color: #888; padding: 12px 0; cursor: pointer; font-weight: bold; font-size: 0.9rem; border-bottom: 2px solid transparent; transition: all 0.2s; }
.tab-btn:hover { color: #ccc; background: #181818; }
.tab-btn.active { color: #fff; background: #1a1a1a; border-bottom: 2px solid #4CAF50; }
.close-tab-btn { background: #d32f2f; color: white; border: none; width: 40px; flex-shrink: 0; cursor: pointer; font-size: 16px; font-weight: bold; display: flex; align-items: center; justify-content: center; }
.close-tab-btn:hover { background: #b71c1c; }

/* === EDITOR CONTENT (Stable Gutter + Offset Padding) === */
.sidebar-scroll-content { flex: 1; overflow-y: auto; overflow-x: hidden; padding-bottom: 40px; padding-top: 15px; scrollbar-gutter: stable; scrollbar-width: thin; scrollbar-color: #444 transparent; }
.editor-section { padding: 5px 2px 5px 10px; width: 100%; box-sizing: border-box; border-bottom: 1px solid #222; }
.info-text { background: #252525; padding: 15px; border-radius: 4px; color: #aaa; font-size: 0.9rem; line-height: 1.4; text-align: center; margin: 10px; }

/* === FLOATING LABEL INPUTS === */
.input-group { position: relative; margin-bottom: 5px; width: 100%; background: #252525; border: 1px solid #333; border-radius: 4px; transition: border-color 0.2s; }
.input-group:focus-within { border-color: #4CAF50; background: #2a2a2a; }
.input-group input, .input-group textarea { width: 100%; background: transparent; border: none; color: #eee; padding: 6px 8px; font-size: 0.9rem; z-index: 2; position: relative; font-family: inherit; resize: vertical; display: block; }
.input-group input:focus, .input-group textarea:focus { outline: none; }
.input-label { position: absolute; right: 8px; color: #555; font-size: 0.75rem; pointer-events: none; font-weight: 600; text-transform: uppercase; z-index: 1; transition: opacity 0.2s; white-space: nowrap; }
.input-group input + .input-label { top: 50%; transform: translateY(-50%); }
.input-group textarea + .input-label { bottom: 6px; right: 8px; }
.input-label.label-hidden { opacity: 0 !important; }

/* === EDITOR UI HELPERS === */
.row-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 100%; }
.row-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; width: 100%; }
.row-4 .input-group input { text-align: center; padding: 6px 2px; }
.row-4 .input-label { display: none; }
.accordion-header { cursor: pointer; padding: 6px 0; display: flex; justify-content: space-between; color: #4CAF50; font-weight: bold; border-bottom: 1px solid #222; user-select: none; font-size: 0.9em; }
.accordion-header::after { content: '‚ñº'; font-size: 0.8em; transition: transform 0.2s; }
.accordion-header.collapsed::after { transform: rotate(-90deg); }
.accordion-content { display: block; overflow: hidden; padding: 5px 0; }
.accordion-content.collapsed { display: none; }
.row-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 5px; }
.action-btn { width: 100%; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold; color: white; border: none; font-size: 0.9rem; }
.btn-delete { background: #500; border: 1px solid #700; }
.btn-delete:hover { background: #700; }
.btn-add { background: #333; border: 1px solid #444; }
.btn-add:hover { background: #444; }
.primary-btn { background: #2e7d32; color: white; border: none; width: 100%; padding: 10px; border-radius: 4px; font-weight: bold; }

/* === RULE BUILDER & SCROLLBARS === */
.compact-list { display: flex; flex-direction: column; gap: 6px; width: 100%; }
.compact-row { display: grid; grid-template-columns: 35% 1fr 24px; gap: 4px; align-items: center; }
.compact-row select, .compact-row input { background: #222; border: 1px solid #333; color: #ddd; padding: 4px; border-radius: 3px; width: 100%; }
.icon-btn { background: #d32f2f; color: white; border: none; border-radius: 3px; width: 24px; height: 24px; cursor: pointer; }
.full-width-btn { width: 100%; padding: 8px; background: #333; border: 1px solid #444; color: #ccc; cursor: pointer; border-radius: 4px; margin-top: 5px; font-weight: bold; font-size: 0.85rem; }
.code-editor { width: 100%; height: 200px; background: #111; color: #0f0; font-family: monospace; font-size: 0.8rem; border: 1px solid #333; border-radius: 4px; padding: 5px; box-sizing: border-box; resize: vertical; }
.code-editor:focus { outline: none !important; border-color: #4CAF50; box-shadow: none; }
::-webkit-resizer { background: linear-gradient(135deg, transparent 70%, #666 70%); }
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: #666; }

/* === MOBILE === */
@media (max-width: 1200px) { .editor-sidebar { width: 100%; max-width: 340px; } body.edit-mode-active #game-wrapper { margin-right: 0; } }
@media (max-width: 768px) { .top-controls { top: 5px; right: 5px; gap: 5px; } .ctrl-btn { padding: 6px 10px; font-size: 12px; } #points-bar { gap: 20px; padding: 10px; } }
</file>

<file path="styles/themes.css">

</file>

