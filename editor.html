<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAM Bounding Box Editor</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2b2b2b;
            color: #eee;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Боковая панель управления */
        #sidebar {
            width: 300px;
            background-color: #333;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
        }

        h2 { margin-top: 0; font-size: 1.2rem; color: #4CAF50; }
        label { display: block; margin-bottom: 5px; font-size: 0.9rem; color: #aaa; }
        
        input[type="file"] {
            margin-bottom: 10px;
            font-size: 0.8rem;
        }

        .control-group {
            border-top: 1px solid #444;
            padding-top: 15px;
        }

        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #555;
            color: white;
            box-sizing: border-box;
            margin-bottom: 10px;
        }

        button {
            width: 100%;
            padding: 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            transition: background 0.2s;
            margin-bottom: 5px;
        }

        .btn-green { background-color: #4CAF50; color: white; }
        .btn-green:hover { background-color: #45a049; }
        
        .btn-red { background-color: #d32f2f; color: white; }
        .btn-red:hover { background-color: #b71c1c; }

        .btn-blue { background-color: #2196F3; color: white; }
        .btn-blue:hover { background-color: #1976D2; }

        /* Область редактора */
        #workspace {
            flex-grow: 1;
            position: relative;
            overflow: auto; /* Скролл если картинка большая */
            background-color: #1e1e1e;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
        }

        canvas {
            background-image: linear-gradient(45deg, #2a2a2a 25%, transparent 25%), 
                              linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #2a2a2a 75%), 
                              linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            cursor: crosshair;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>SAM Box Editor</h2>
    
    <div>
        <label>1. Загрузи Картинку:</label>
        <input type="file" id="imgInput" accept="image/*">
    </div>

    <div>
        <label>2. Загрузи JSON (optional):</label>
        <input type="file" id="jsonInput" accept=".json">
    </div>

    <div class="control-group" id="editControls" style="display:none;">
        <label>Выбранный элемент (ID):</label>
        <input type="text" id="itemIdInput" placeholder="ID элемента">
        
        <div style="display: flex; gap: 5px;">
            <input type="number" id="inpX" placeholder="X">
            <input type="number" id="inpY" placeholder="Y">
        </div>
        <div style="display: flex; gap: 5px;">
            <input type="number" id="inpW" placeholder="W">
            <input type="number" id="inpH" placeholder="H">
        </div>

        <button class="btn-red" onclick="deleteSelected()">Удалить (Del)</button>
    </div>

    <div class="control-group">
        <button class="btn-blue" onclick="addNewBox()">+ Добавить рамку</button>
        <button class="btn-green" onclick="downloadJSON()">Скачать JSON</button>
    </div>

    <div style="margin-top: auto; font-size: 0.8rem; color: #777;">
        <p>Левый клик - тащить.</p>
        <p>Красный угол - менять размер.</p>
    </div>
</div>

<div id="workspace">
    <canvas id="canvas"></canvas>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Inputs
    const imgInput = document.getElementById('imgInput');
    const jsonInput = document.getElementById('jsonInput');
    const itemIdInput = document.getElementById('itemIdInput');
    const editControls = document.getElementById('editControls');
    const inpX = document.getElementById('inpX');
    const inpY = document.getElementById('inpY');
    const inpW = document.getElementById('inpW');
    const inpH = document.getElementById('inpH');

    // State
    let image = null;
    let boxes = []; // Array of {id, x, y, w, h}
    let selectedIndex = -1;
    
    // Dragging State
    let isDragging = false;
    let isResizing = false;
    let dragStartX, dragStartY;
    let initialRect = {};
    const HANDLE_SIZE = 10; // Размер квадратика для ресайза

    // --- 1. LOAD IMAGE ---
    imgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            image = new Image();
            image.onload = () => {
                canvas.width = image.width;
                canvas.height = image.height;
                draw();
            };
            image.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    // --- 2. LOAD JSON ---
    jsonInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = JSON.parse(event.target.result);
                parseBoxData(data);
                draw();
            } catch(err) {
                alert("Ошибка чтения JSON: " + err);
            }
        };
        reader.readAsText(file);
    });

    // Функция парсинга, аналогичная твоему Python скрипту
    function parseBoxData(data) {
        boxes = [];
        let rawItems = [];

        // Собираем все элементы (плоские или группы)
        if (data.items && Array.isArray(data.items)) {
            rawItems.push(...data.items);
        }
        if (data.groups && Array.isArray(data.groups)) {
            data.groups.forEach(g => {
                if(g.items) rawItems.push(...g.items);
            });
        }

        // Нормализуем данные
        rawItems.forEach(item => {
            let x=0, y=0, w=100, h=100;
            let found = false;

            // Вариант 1: coords: {x,y,w,h}
            if (item.coords && typeof item.coords === 'object' && !Array.isArray(item.coords)) {
                if('x' in item.coords) {
                    x = item.coords.x; y = item.coords.y; w = item.coords.w; h = item.coords.h;
                    found = true;
                }
            } 
            // Вариант 2: coords: [x,y,w,h]
            else if (item.coords && Array.isArray(item.coords)) {
                [x, y, w, h] = item.coords;
                found = true;
            }
            // Вариант 3: coords_px: [x,y,w,h] (или x1,y1,x2,y2, но предполагаем x,y,w,h как в твоем скрипте)
            else if (item.coords_px && Array.isArray(item.coords_px)) {
                [x, y, w, h] = item.coords_px;
                found = true;
            }

            if(found) {
                boxes.push({
                    id: item.id || "unknown",
                    x: parseInt(x),
                    y: parseInt(y),
                    w: parseInt(w),
                    h: parseInt(h)
                });
            }
        });
        console.log(`Загружено ${boxes.length} рамок`);
    }

    // --- 3. DRAWING ---
    function draw() {
        // Очистка
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Рисуем картинку
        if (image) {
            ctx.drawImage(image, 0, 0);
        } else {
            ctx.fillStyle = "#333";
            ctx.font = "20px Arial";
            ctx.fillText("Сначала загрузите картинку", 50, 50);
        }

        // Рисуем рамки
        boxes.forEach((box, index) => {
            const isSelected = (index === selectedIndex);
            
            // Цвет рамки
            ctx.strokeStyle = isSelected ? "#FFD700" : "#00FF00"; // Золотой если выбран, Зеленый если нет
            ctx.lineWidth = isSelected ? 3 : 2;
            
            // Сама рамка
            ctx.strokeRect(box.x, box.y, box.w, box.h);

            // Текст ID
            ctx.font = "bold 16px Arial";
            const text = box.id;
            const textWidth = ctx.measureText(text).width;
            
            // Фон под текстом
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(box.x, box.y - 20, textWidth + 10, 20);
            
            // Сам текст
            ctx.fillStyle = "#FFF";
            ctx.fillText(text, box.x + 5, box.y - 5);

            // Если выбран - рисуем "ручку" для ресайза в правом нижнем углу
            if(isSelected) {
                ctx.fillStyle = "red";
                ctx.fillRect(box.x + box.w - HANDLE_SIZE, box.y + box.h - HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE);
            }
        });
    }

    // --- 4. INTERACTION ---

    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY
        };
    }

    // Проверка попадания в ручку ресайза (правый нижний угол)
    function isResizeHandle(x, y, box) {
        return (x >= box.x + box.w - HANDLE_SIZE && x <= box.x + box.w &&
                y >= box.y + box.h - HANDLE_SIZE && y <= box.y + box.h);
    }

    // Проверка попадания внутрь рамки
    function isInsideBox(x, y, box) {
        return (x >= box.x && x <= box.x + box.w && y >= box.y && y <= box.y + box.h);
    }

    canvas.addEventListener('mousedown', (e) => {
        const pos = getMousePos(e);
        
        // Сначала проверяем ресайз выбранного элемента
        if (selectedIndex !== -1) {
            const box = boxes[selectedIndex];
            if (isResizeHandle(pos.x, pos.y, box)) {
                isResizing = true;
                initialRect = {...box};
                dragStartX = pos.x;
                dragStartY = pos.y;
                return;
            }
        }

        // Ищем клик по рамке (обратный порядок, чтобы выбирать верхние)
        let foundIndex = -1;
        for (let i = boxes.length - 1; i >= 0; i--) {
            if (isInsideBox(pos.x, pos.y, boxes[i])) {
                foundIndex = i;
                break;
            }
        }

        if (foundIndex !== -1) {
            selectedIndex = foundIndex;
            isDragging = true;
            dragStartX = pos.x;
            dragStartY = pos.y;
            initialRect = {...boxes[selectedIndex]};
            updateSidebarInputs();
        } else {
            selectedIndex = -1;
            editControls.style.display = 'none';
        }
        draw();
    });

    canvas.addEventListener('mousemove', (e) => {
        const pos = getMousePos(e);

        // Меняем курсор
        let cursor = 'default';
        if (selectedIndex !== -1 && isResizeHandle(pos.x, pos.y, boxes[selectedIndex])) {
            cursor = 'nwse-resize';
        } else {
            // Проверка наведения на любую рамку
             for (let i = boxes.length - 1; i >= 0; i--) {
                if (isInsideBox(pos.x, pos.y, boxes[i])) {
                    cursor = 'move';
                    break;
                }
            }
        }
        canvas.style.cursor = cursor;

        if (isDragging && selectedIndex !== -1) {
            const dx = pos.x - dragStartX;
            const dy = pos.y - dragStartY;
            boxes[selectedIndex].x = initialRect.x + dx;
            boxes[selectedIndex].y = initialRect.y + dy;
            updateSidebarInputs();
            draw();
        } else if (isResizing && selectedIndex !== -1) {
            const dx = pos.x - dragStartX;
            const dy = pos.y - dragStartY;
            // Минимальный размер 10x10
            boxes[selectedIndex].w = Math.max(20, initialRect.w + dx);
            boxes[selectedIndex].h = Math.max(20, initialRect.h + dy);
            updateSidebarInputs();
            draw();
        }
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
        isResizing = false;
    });

    // --- 5. UI CONTROLS ---

    function updateSidebarInputs() {
        if (selectedIndex === -1) {
            editControls.style.display = 'none';
            return;
        }
        const box = boxes[selectedIndex];
        editControls.style.display = 'block';
        itemIdInput.value = box.id;
        inpX.value = Math.round(box.x);
        inpY.value = Math.round(box.y);
        inpW.value = Math.round(box.w);
        inpH.value = Math.round(box.h);
    }

    // Слушатели изменений в инпутах
    itemIdInput.addEventListener('input', (e) => {
        if(selectedIndex !== -1) {
            boxes[selectedIndex].id = e.target.value;
            draw();
        }
    });

    [inpX, inpY, inpW, inpH].forEach(inp => {
        inp.addEventListener('input', () => {
            if(selectedIndex !== -1) {
                boxes[selectedIndex].x = parseInt(inpX.value) || 0;
                boxes[selectedIndex].y = parseInt(inpY.value) || 0;
                boxes[selectedIndex].w = parseInt(inpW.value) || 20;
                boxes[selectedIndex].h = parseInt(inpH.value) || 20;
                draw();
            }
        });
    });

    function deleteSelected() {
        if(selectedIndex !== -1) {
            boxes.splice(selectedIndex, 1);
            selectedIndex = -1;
            updateSidebarInputs();
            draw();
        }
    }

    // Горячая клавиша Delete
    window.addEventListener('keydown', (e) => {
        if (e.key === 'Delete' && selectedIndex !== -1) {
            // Проверка, что фокус не в инпуте
            if(document.activeElement.tagName !== 'INPUT') {
                deleteSelected();
            }
        }
    });

    function addNewBox() {
        if(!image) {
            alert("Сначала загрузи картинку, чтобы знать размеры!");
            return;
        }
        // Добавляем в центр экрана (или холста)
        const newBox = {
            id: "new_item_" + (boxes.length + 1),
            x: 50,
            y: 50,
            w: 200,
            h: 200
        };
        boxes.push(newBox);
        selectedIndex = boxes.length - 1;
        updateSidebarInputs();
        draw();
    }

    function downloadJSON() {
        if(boxes.length === 0) {
            alert("Нет данных для сохранения");
            return;
        }

        // Формируем структуру как в примере JSON
        const output = {
            items: boxes.map(b => ({
                id: b.id,
                coords: {
                    x: Math.round(b.x),
                    y: Math.round(b.y),
                    w: Math.round(b.w),
                    h: Math.round(b.h)
                }
            }))
        };

        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(output, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "updated_boxes.json");
        document.body.appendChild(downloadAnchorNode); // required for firefox
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    }

</script>

</body>
</html>